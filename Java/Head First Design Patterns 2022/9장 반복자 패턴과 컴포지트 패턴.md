# 반복자 패턴(Iterator pattern)

>컬렉션의 구현 방법을 노출하지 않으면서 집합체 내의 모든 항목에 접근하는 방법을 제공한다.

<br>

### 가게 메뉴 통합 예제

케잌가게와 식당에서 각각 메뉴를 제공

#### 메뉴아이템
```java
public class MenuItem {
	String name;
	String description;
	boolean vegetarian;
	double price;
 
    ...
    // constructor
    // get/set...
}
```

#### 케잌가게 메뉴
```java
public class PancakeHouseMenu {
	List<MenuItem> menuItems;   // List
 
	public PancakeHouseMenu() {
		menuItems = new ArrayList<MenuItem>();
    
		addItem(...);
        ...
	}

	public void addItem(String name, String description,
	                    boolean vegetarian, double price) {
		// 리스트에 아이템 추가
		...
	}
 
 	// Return List<>
	public List<MenuItem> getMenuItems() {
		return menuItems;
	}
    ...
}
```

### 식당 메뉴
```java
public class DinerMenu {
	static final int MAX_ITEMS = 6;
	int numberOfItems = 0;
	MenuItem[] menuItems;   // Array
  
	public DinerMenu() {
		menuItems = new MenuItem[MAX_ITEMS];
 
		addItem(...);
		...
	}
  
	public void addItem(String name, String description, 
	                     boolean vegetarian, double price) {
		// 배열에 아이템 추가
		...
	}
 
	public MenuItem[] getMenuItems() {
		return menuItems;
	}
    ...
}
```

### 각 가게 메뉴 호출
```java
PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();
DinerMenu dinerMenu = new DinerMenu();

List<MenuItem> breakfastItems = pancakeHouseMenu.getMenuItems();
MenuItem[] lunchItems = dinerMenu.getMenuItems();
```
#### 반환된 배열과, 리스트 각각에 맞는 순환문 코드를 구현해야 하는 문제

<br>

### 반복을 캡슐화
`java.util.Iterator` 인터페이스 사용 

#### UML
![image](https://user-images.githubusercontent.com/4969393/204129450-5bc04335-b5b9-4d76-baa3-cdeace41cbc6.png)

```java
public class DinerMenuIterator implements Iterator<MenuItem> {
	MenuItem[] list;
	int position = 0;
 
	public DinerMenuIterator(MenuItem[] list) {
		this.list = list;
	}
 
	public MenuItem next() {
		MenuItem menuItem = list[position];
		position = position + 1;
		return menuItem;
	}
 
	public boolean hasNext() {
		if (position >= list.length || list[position] == null) {
			return false;
		} else {
			return true;
		}
	}

	public void remove() {
		...
	}
}
```

```java
public interface Menu {
	public Iterator<MenuItem> createIterator();
}
```

```java
public class DinerMenu implements Menu {
	static final int MAX_ITEMS = 6;
	int numberOfItems = 0;
	MenuItem[] menuItems;
    
    ...
  
	public Iterator<MenuItem> createIterator() {
		return new DinerMenuIterator(menuItems);
	} 
}
```

#### Client

>`Iterator` 로 컬렉션의 구현 방법을 노출하지 않으면서 집합체 내의 모든 항목에 접근하는 방법을 제공한다.

```java
public class Waitress {
	Menu pancakeHouseMenu;
	Menu dinerMenu;

	public Waitress(Menu pancakeHouseMenu, Menu dinerMenu) {
		this.pancakeHouseMenu = pancakeHouseMenu;
		this.dinerMenu = dinerMenu;
	}

	public void printMenu() {
		Iterator<MenuItem> dinerIterator = dinerMenu.createIterator();
		Iterator<MenuItem> pancakeIterator = pancakeHouseMenu.createIterator();

		printMenu(dinerIterator);
		printMenu(pancakeIterator);
	}

	private void printMenu(Iterator<MenuItem> iterator) {
		while (iterator.hasNext()) {
			MenuItem menuItem = iterator.next();
			System.out.print(menuItem.getName() + ", ");
		}
	}
```

#### UML
![](https://blog.kakaocdn.net/dn/ARh75/btqAy2u00m3/Lum3YjmKrA5iJy4VIcwPZ0/img.png)

<br>

# 컴포지트 패턴(composite pattern)
