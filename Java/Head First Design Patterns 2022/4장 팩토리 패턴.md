## 팩토리 메서드 패턴 (Factory method pattern)

>팩토리 메서드 패턴은 객체지향 디자인 패턴이다.   
`Factory method`는 부모(상위) 클래스에 알려지지 않은 구체 클래스를 생성하는 패턴이며,  
자식(하위) 클래스가 어떤 객체를 생성할지를 결정하도록 하는 패턴이기도 하다.  
부모(상위) 클래스 코드에 구체 클래스 이름을 감추기 위한 방법으로도 사용한다.

### 피자 코드 만들기 

```java
Pizza orderPizza(String type) {
    Pizza pizza;
    
    // 피자 종류에따라 구상 클래스의 인스턴스를 만들고 pizza 인스턴스변수에 대입.
    // 모든 피자 클래스는 'Pizza' 인터페이스를 구현
    if (type.equals("cheese")) {
        pizza = new CheesePizza(); 
    } elseif(type.equals("greek")) {
        pizza = new GreekPizza(); 
    } else if (type.equals("pepperoni") { 
        pizza = new PepperoniPizza();
    }
    
    // 피자를 만드는데 공통적인 과정
    pizza.prepare();
    pizza.bake();
    pizza.cut();
    pizza.box();
    return pizza;
 }
```
위 코드는 피자의 종류가 추가되거나 삭제될 때마다 코드를 수정해야하는 문제가 있음! (ex. 야채피자가 추가되면 if-else 구문이 추가됨)
#### 가장 큰 문제는 인스턴스를 만드는 구상 클래스를 선택하는 부분. 캡슐화가 필요함.

### 객체 생성 부분 캡슐화

피자 객체 생성을 전담하는 클래스
```java
public class SimplePizzaFactory {

    public Pizza createPizza(String type) {
        Pizza pizza = null;

        if (type.equals("cheese")) {
            pizza = new CheesePizza();
        } else if (type.equals("pepperoni")) {
            pizza = new PepperoniPizza();
        } else if(type.equals("clam")) {
            pizza = new ClamPizza();
        } else if(type.equals("veggie")) {
            pizza = new VeggiePizza();
        }
    return pizza;
    }
}
```
객체생성 팩토리 클래스를 캡슐화하면 구현 변경 시 팩토리 클래스 하나만 수정하면 되는 장점이 있음

### 클라이언트 코드 수정
```java
public class PizzaStore {
    SimplePizzaFactory factory;

    public PizzaStore(SimplePizzaFactory factory) {
        this.factory = factory;
    }

    public Pizza orderPizza(String type) {
        // 구상 클래스의 인스턴스를 만들지 않고(new) 팩토리 객체의 `create`메서드 사용
        Pizza pizza = factory.createPizza(type);

        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();

        return pizza;
    }
}
```

### 간단한 팩토리 의 정의
>지금까지 만든어 본 것은 디자인 패턴이라기보다는 프로그래밍에서 자주 쓰이는 관용구에 가깝고 정확하게는 팩토리 패턴이 아니다.

### 피자가게 프레임워크 만들기

피자 만드는 일을 전부 PizzaStore 클래스에서 진행하면서 지점의 스타일을 살리는 방법

- SimplePizzaFactory를 삭제하고 3가지 서로 다른 팩토리 (NYPizzaFactory, ChicagoPizza Factory, CaliforniaPizzaFactory)를 만든 다음,  
PizzaStore에서 적당한 팩토리를 사용하도록 함.

팩터리 메서드 선언
```java
// 추상클래스
public abstract class PizzaStore {

    public Pizza orderPizza(String type) {
        Pizza pizza = createPizza(type);  //서브클래스에서 피자 스타일을 결정(뉴욕, 시카고, 캘리포니아)

        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();

        return pizza;
    }

    // 팩토리 객체 대신 이 팩터리 메서드를 사용
    // 추상 메서드이기에 서브 클래스는 반드시 이 메서드를 구현해야 한다
    abstract Pizza createPizza(String type); 
}
```

구조

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcXZnaY%2FbtrCmeuWhnW%2FhXmXRGeLC4kgIu4xjccklK%2Fimg.png)

`NYStylePizzaStore`
```java
public class NYStylePizzaStore extends PizzaStore {
  @Override
  Pizza createPizza(String type) {
      if (type.equals("cheese")) {
          return new NYStyleCheesePizza();
      } else if (type.equals("pepperoni")) {
          return new NYStylePepperoniPizza();
      } else if(type.equals("clam")) {
          return new NYStyleClamPizza();
      } 
      ...
  }
}
```

`ChicagoStylePizzaStore`
```java
public class NYStylePizzaStore extends PizzaStore {
  @Override
  Pizza createPizza(String type) {
      if (type.equals("cheese")) {
          return new ChicagoStyleCheesePizza();
      } else if (type.equals("pepperoni")) {
          return new ChicagoStylePepperoniPizza();
      } else if(type.equals("clam")) {
          return new ChicagoStyleClamPizza();
      }
      ...
  }
}
```



