## 싱글턴 패턴

>클래스 인스턴스를 하나만 만들고, 그 인스턴스로의 전역 접근을 제공한다.

![](https://fjp.at/assets/pages/design-patterns/singleton-pattern.png)

## 이번 장 결론
 `Enum` 싱글턴을 써라
 
```java
public enum Singleton {
  UNIQUE_INSTANCE; 
  ...
}

public class SingletonClient {
    public static void main(String[] args) {
        Singleton singleton = Singleton.UNIQUE_INSTANCE;
    }
}
```
<br>

#### 고전적인 싱글턴 패턴
```java
public class Singleton {
	private static Singleton uniqueInstance;
 
	private Singleton() {}
 
	public static Singleton getInstance() {
		if (uniqueInstance == null) {
			uniqueInstance = new Singleton();
		}
		return uniqueInstance;
	}
}
```

#### 멀티스레딩 문제

여러 스레드가 동시에 `if (uniqueInstance == null) {...}` 구문 안에 진입 한다면?
```java
public class ChocolateBoiler {
	private boolean empty;
	private boolean boiled;
	private static ChocolateBoiler uniqueInstance;
  
	private ChocolateBoiler() {
		empty = true;
		boiled = false;
	}
  
	public static ChocolateBoiler getInstance() {
		if (uniqueInstance == null) {
			System.out.println("Creating unique instance of Chocolate Boiler");
			uniqueInstance = new ChocolateBoiler();
		}
		System.out.println("Returning instance of Chocolate Boiler");
		return uniqueInstance;
	}

	public void fill() {
		if (isEmpty()) {
			empty = false;
			boiled = false;
			// fill the boiler with a milk/chocolate mixture
		}
	}
 
	public void drain() {
		if (!isEmpty() && isBoiled()) {
			// drain the boiled milk and chocolate
			empty = true;
		}
	}
 
	public void boil() {
		if (!isEmpty() && !isBoiled()) {
			// bring the contents to a boil
			boiled = true;
		}
	}
  
	public boolean isEmpty() {
		return empty;
	}
 
	public boolean isBoiled() {
		return boiled;
	}
}
```

#### 멀티스레딩 문제 해결

`synchronized` 키워드로 동기화
```java
public static synchronized ChocolateBoiler getInstance() {
    if (uniqueInstance == null) {
        System.out.println("Creating unique instance of Chocolate Boiler");
        uniqueInstance = new ChocolateBoiler();
    }
    System.out.println("Returning instance of Chocolate Boiler");
    return uniqueInstance;
}
```
- 문제는 `uniqueInstance` 에 인스턴스를 할당하면 그 후로는 굳이 동기화가 필요없다

#### 더 효율적인방법 

1. `getInstance()`의 속도가 중요하지 않다면 그냥 둔다.
- 다만 메서드를 동기화하면 성능이 100배 정도 저하된다

2. 인스턴스가 필요할 때는 생성하지 말고 처음부터 만든다.

```java
public class Singleton {
  private static Singleton uniqueInstance = new Singleton();
  
  private Singleton() {}
  
  public static Singleton getInstance() {
    return uniqueInstance;
  }
}
```

3. `DCL` 을 써서 getInstance()에서 동기화되는 부분을 줄인다

- DCL(Double-Chekced Locking)를 사용하면 인스턴스가 생성되어 있지 않았을 때, 즉 처음만 동기화 할 수 있다.

```java
public class Singleton {
  private volatile static Singleton uniqueInstance = new Singleton();
  
  private Singleton() {}
  
  public static Singleton getInstance() {
    if(uniqueInstance == null) {
        synchronized (Signleton.class) {
            if(uniqueInstance == null) {
                uniqueInstance = new Singleton();
            }
        }
    }
    return uniqueInstance;
  }
} 
```

* `volatile` 키워드를 사용하면 CPU 캐시외에 메인 메모리 변수 값을 저장하고 모든 읽기는 메인 메모리에서 직접 읽는다.  
(cpu 캐시 내에서만 값이 변화하던 것 들을 메인 메모리에도 반영)

CPU Cache

![](https://nesoy.github.io/assets/posts/20180609/1.png)

 ### Enum 싱글턴
 
```java
public enum Singleton {
  UNIQUE_INSTANCE; 
  ...
}

public class SingletonClient {
    public static void main(String[] args) {
        Singleton singleton = Singleton.UNIQUE_INSTANCE;
    }
}
```

<br>

참조 : https://nesoy.github.io/articles/2018-06/Java-volatile
