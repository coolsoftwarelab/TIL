## 아이템26. 로 타입(Raw type) 은 사용하지 말라

### Raw type
> 제네릭 타입에서 타입정보가 빠진 것. `List<String>` 에서 `List` 를 뜻함.

### Raw type 은 오직 제네릭 사용 이전의 버전과 호환하기 위해 남아있으니 사용하지 말아야 한다.

<br>/<br>
## 아이템27. 비검사 경고를 제거하라

비검사 경고(unchecked warnings)를 제거하면 런타임에 형변환 관련 예외(ClassCastException)가 발생할 일이 없으며 코드의 올바른 동작도 기대할 수 있게 된다.

만일 경고를 제거할 수 없지만 타입이 안전하다고 확신할 수 있다면 @SuppressWarnings("unchecked") 어노테이션을 붙여 경고를 숨기자.  
리턴 문장을 제외한 개별 지역변수 선언부터 클래스 전체까지 어떤 선언에도 달 수 있지만, 가능한 좁은 범위에 적용해야 한다. 이 때는 경고를 무시해도 안전한 이유를 주석으로 같이 남겨두도록 하자.

<br></br>
## 아이템28. 배열보다는 리스트를 사용하라.

### 배열과 제너릭 타입의 차이

### 1. 공변(covariant) vs 비공변(invariant)

- 배열은 공변(covariant)  
Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이다. (공변, 즉 함께 변한다)

- 제너릭은 불공변(invariant)  
`List<Sub>` 은 `List<Super>` 의 하위 타입도 아니고 상위 타입도 아니다.


**배열의 문제점**

런타임에서 에러 발생 (배열)
```java
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없다";  // ArrayStoreException
```

컴파일에서 에러 발생 (제너릭)
```java
List<Object> ol = new ArrayList<Long>();  // 호환되지 않음
ol.add("타입이 달라 넣을 수 없다");
```

*제너릭을 사용하면 컴파일 단계에서 에러 잡을 수 있다.

### 2. 배열은 실체화/구체화(reify) 된다.
- 배열 : 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다.  
- 제너릭 : 타입 정보가 런타임에서는 소거(erasure) 된다.

Ex) 제너릭 소거  
`List<Integer>` 런타임에서는 `List`
`List<Integer>[]` 런타임에서는 `List[]`

*제너릭의 소거는 자바5 에서 하위 호환성을 위해 사용됨.

### 실체화 불가 타입

`E`, `List<E>`, `List<String>` 같은 타입을 실체화 불가 타입(non-reifiable type)이라 한다.  
제네릭 소거로 인해 실체화되지 않아서 런타임 시점에 컴파일타임보다 타입 정보를 적게 가지는 타입을 말한다.

제너릭 소거로 인해 매개변수화 타입 가운데 실체화될 수 있는 타입은 `List<?>`와 Map`<?,?>` 같은 비한정적 와일드카드 타입뿐이다.
### 코드예시 필요

### 제너릭 배열 생성은 허용하지 않는다.  

아래는 허용하지 않는 이유 예시.
```java
List<String>[] stringLists = new List<String>[1];  // (1) 
List<Integer> intList = List.of(42);               // (2) 
Object[] objects = stringLists;                    // (3) 
objects[0] = intList;                              // (4)
String s = stringLists[0].get(0);                  // (5)
```

(1) 허용된다고 가정 해보자.

(2) 원소가 하나인 `List<Integer>` 생성

(3) 배열은 공변이니 문제 없음. (`List<StringL>[]` -> `Object[]`)

(4) `List<Integer>` 인스턴스를 Object배열 첫 원소로 저장. 제너릭은 런타임에서 타입 정보가 소거 되므로 성공.

(5) stringLists[0].get(0) 의 원소는 Integer 이므로 런타임에서 ClassCastException 발생

따라서, 제너릭 배열이 생성되지 않도록 (1)에서 컴파일 오류를 내야 한다.

제너릭 적용해야 하는 예시
```java
public class Chooser {
    private final Object[] choiceArray;
    
    public Chooser(Collection choices) {
        this.choiceArray = choices.toArray();
    }
    
    // 이 메서드를 사용하는 곳에서는 매번 형변환이 필요하다.
    // 형변환 오류의 가능성이 있다.
    public Object choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceArray[rnd.nextInt(choiceArray.length)];
    }
}
```

제너릭 사용 시도 (1) - 컴파일 되지 않는다.
```java
public class Chooser<T> {
    private final T[] choiceArray;

    public Chooser(Collection<T> choices) {
        // 오류 발생 incompatible types: java.lang.Object[] cannot be converted to T[]
        this.choiceArray = choices.toArray();
    }

    // choose 메소드는 동일.
}
```

incompatible types 오류 해결
```java
// Object 배열을 T 배열로 형변환하면 된다.
this.choiceArray = (T[]) choices.toArray();
```

제너릭 사용 최종  
Unchecked Cast과 같은 비검사 형변환 경고를 제거를 위해 배열 대신 리스트 사용
```java
class Chooser<T> {
    private final List<T> choiceList;

    public Chooser(Collection<T> choices) {
        this.choiceList = new ArrayList<>(choices);
    }

    public T choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceList.get(rnd.nextInt(choiceList.size()));
    }
}
```

<br></br>
## 아이템29. 이왕이면 제네릭 타입으로 만들어라

>클라이언트에서 직접적으로 형변환을 해야 하는 타입보다는 제네릭 타입이 더 안전하고 사용하기에도 편리하다

#### 클래스를 제네릭 클래스로 만드는 방법

1. 클래스 선언에 타입 매개변수 추가 (ex. `<T>`)
2. 일반 타입(ex. Object)을 타입 매개변수로 교체
3. 비검사(unchekced)경고 해결


#### 한정적 타입 매개변수(bounded type parameter)

```
class MySub<E extends MySuper>  // E는 MySuper 의 하위타입만 받는다는 뜻
```

#### 직접 형변환하는 것보다 제네릭 타입이 더 안전하고 간편하다.

<br></br>
## 아이템30. 이왕이면 제네릭 메서드로 만들라

>명시적으로 파라미터와 반환값을 형변환해야하는 메서드 대신 형변환에 안전하고 편한 제네릭 메서드를 사용하자.

raw 타입을 사용한 메서드 - 좋지않다!
```java
public static Set union(Set s1, Set s2) {
    Set result = new HashSet<>();
    result.addAll(s2);
    return result;
}
```
- 컴파일은 되지만 경고발생 (unchecked call to ... as a memeber of raw type Set) 등

제네릭 메서드 (안전한 타입 매개변수)

```java
public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
    Set<E> result = new HashSet<>(s1);
    result.addAll(s2);
    return result;
}
```
- `<E>` 는 타입 매개변수 목록
- `Set<E>` 는 반환타입

제네릭 메서드 예시
```java
main() {
    Set<String> set1 = Set.of("A", "B", "C");
    Set<String> set2 = Set.of("D", "E", "F");
    Set<String> mergedSet = union(set1, set2);
    println(mergedSet)
    
>>>결과
[A, B, C, D, E, F]
}
```

<br></br>
## 아이템31. 한정적 와일드카드를 사용해 API 유연성을 높이라

<br></br>
## 아이템32. 제네릭과 가변인수를 함께 쓸 때는 신중하라

<br></br>
## 아이템33. 타입 안전 이종 컨테이너를 고려하라

### 타입 안전 이종(혼성) 컨테이너 (Type safe heterogeneous container pattern)

*heterogeneous : 여러 다른 종류들로 이루어진.  

*컨테이너 : 객체를 저장하는 역할을 하는 클래스
- Collections(List, Set, Queue)
- Map

`Set<E>` 은 하나의 타입 매개변수, `Map<K, V>` 키와 값의 타입을 뜻하는 2개의 타입 매개변수

위 케이스 외에 타입의 수에 제약없이 사용 또는 특정 타입 외에 다양한 타입을 지원해야 할 경우가 있다.  
Ex) DB row 의 임의 개수의 열(column) 타입을 안전하게 이용할 때

컨테이너 대신 키를 매개변수화 한 다음 컨테이너에 값을 넣거나, 뺄 때 키 타입을 제공해 주면 된다.  
이것이 타입 안전 이종(혼성) 컨테이너 패턴이다.

```
public class Favorites {
    // class 리터럴이면 무엇이든 넣을 수 있다.
    private Map<Class<?>, Object> favorites = new HashMap<>();
    
    public <T> void putFavorite(Class<T> type, T instance) {
        favorites.put(Objects.requireNonNull(type), instance);
    }

    public <T> T getFavorite(Class<T> type) {
        // cast : 주어진 인수가 Class 객체가 알려주는 타입의인스턴스인지 검사. 틀리면 ClassCastException
        return type.cast(favorites.get(type));
    }

    public static void main(String[] args) {
        Favorites f = new Favorites();
        f.putFavorite(String.class, "Java");
        f.putFavorite(Class.class, Favorites.class);

        String favoriteString = f.getFavorite(String.class);
        Class<?> favoriteClass = f.getFavorite(Class.class);

        // 출력 결과: Java Favorites
        System.out.printf("%s %s%n", favoriteString, favoriteClass.getName());
    }
}
```

- class 의 리터럴의 타입은 제네릭이다. String.class = `Class<String>`
- 컴파일타임 타입 정보와 런타임 타입 정보를 알아내기 위해 메서드들이 주고받는 class 리터럴을 타입 토큰(type token)이라 한다.  

### Favorites 클래스의 두 가지 제약
#### 1. 타입 안정성이 보장되지 않는 경우
```
f.putFavorite((Class)Integer.class, "This is not integer !!!");
Integer notInteger = f.getFavorite(Integer.class); // ClassCastException
```

이를 해결하려면 putFavorite() 에서 type과 instance 가 일치하는지 확인과정이 필요하다.  
동적 형변환으로 런타임 타입 안정성 확보
```
public <T> void putFavorite(Class<T> type, T instance) {
    favorites.put(Objects.requireNonNull(type), type.cast(instance));
}
```

Etc) checkedSet, checkedList, checkedMap 이 이렇게 타입을 확인해주는 컬렉션 레퍼들이다.  
>https://github.com/openjdk/jdk11u/blob/master/src/java.base/share/classes/java/util/Collections.java#L3038-L3148

이종(혼성) 컨테이너를 Map 만으로 구현 할 경우 타입 안전이 보장되지 않는다. (컴파일 단계에서 에러를 찾지 못함)
```
Map<Class, Object> map = new HashMap<Class, Object>();
map.put(String.class, 3);   // 3 이 String이 아니지만 컴파일 통과

String str = (String) map.get(String.class);    // ClassCastException
```

#### 2. 실체화가 불가능한 타입은 넣을 수 없다 (`List<String>`, `List<Integer>` 등등)  

`List<String>.class` 문법오류  
`List<Integer>` 과 `List<String>` => List.class 라는 같은 Class 객체를 공유 하기 때문이다.    

해결하려면 슈퍼 타입 토큰 사용
```
Favorites f = new Favorites();

List<String> pets = Arrays.asList("개", "고양이");

f.putFavorite(new TypeRef<List<String>>(){}, pets);
List<String> list = f.getFavorite(new TypeRef<List<String>>(){});
```

#### 한정적 타입 토큰

Favorites가 사용하는 타입 토큰은 비한정 적이므로, 어떤 Class 객체든 받아들인다. 
때로는 이 메서드들이 허용하는 타입을 제한하고 싶을 떄가 있는데 이때 한정적 타입 토큰을 활용할 수 있다.

```
public <T extends Annotation>
    T getAnnotation(Class<T> annotationType);
```

annotationType 인수는 한정적 타입 토큰이다.  
이 메서드는 토큰으로 명시한 타입의 애너테이션이 대상 요소에 달려 있다면 그 애너테이션을 반환하고, 없다면 null을 반환한다.

한정적 타입 토큰을 받는 메서드에 `Class<?>` 타입의 객체를 넘기려면 asSubclass 메서드 사용  
(호출된 인스턴스 자신의 Class 객체를 인수가 명시한 클래스로 형변환 한다)

형변환에 성공하면, 인수로 받은 클래스 객체를 반환하고

실패하면 ClassCastException을 발생시킨다.

asSubClass 를 사용해 한정적 타입 토큰을 안전하게 형 변환한다.
```
static Annotation getAnnotation(AnnotatedElement element, String annotationTypeName){
    Class<?> annotationType =null; // 비한정적 타입 토큰
    try {
        annotationType = Class.forName(annotationTypeName);
    }
    catch(Exception ex){
        throw new IllegalArgumentException(ex);
    }
 
    return element.getAnnotation(anotationType.asSubclass(Annotation.class)); 
}
```





