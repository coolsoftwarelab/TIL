## 아이템 49. 매개변수가 유효한지 검사하라
- 매개변수에 제약을 두는 게 좋다고 해석하면 안 된다. 메서드는 최대한 범용적으로 설계해야 한다.  
메서드가 건네받은 값으로 제대로 동작할 수 있다면, 매개변수 제약은 적을수록 좋다.
- 메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각해야 하며,  
그 제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사해야 한다.

<br></br>
## 아이템 50. 적시에 방어적 복사본을 만들라

불변식을 기대한 Preriod 코드
```java
public final class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
        if(start.compareTo(end) > 0) {
            throw new IllegalArgumentException(start + " after " + end);
        }
        this.start = start;
        this.end = end;
    }
    public Date start() { return start; }
    public Date end() { return end; }
}
```

불변식을 깨뜨리는 공격코드
```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);

p.end().setMonth(-100);  // p의 내부 수정됨!
```

### 방어적 복사

매개변수의 방어적 복사본을 반환.
```java
public final class Period(Date start, Date end) {
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());

    // 종료시간은 시작시간보다 뒤여야 한다.
    if(start.compareTo(end) > 0) {
        throw new IllegalArgumentException(start + " after " + end);
    }
    
    // 필드의 방어적 복사
    public Date start() {
        return new Date(start.getTime());
    }
    
    public Date end() {
        return new Date(end.getTime());
    }
    
}
```
- 이제 Period는 불변이다.
- Date class는 문제점이 있으니 대신 LocalDateTime이나 ZonedDateTime 을 사용해야 한다.  
또는 불변인 Instant를 사용해도 된다

### 정리
>클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.  
복사 비용이 너무 크거나 클라이언트를 신뢰한다면 방어적 복사를 수행하는 대신 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하도록 하자.


### 얉은 복사 VS 깊은 복사

- 얉은 복사
```java
class ShallowDummy implements Cloneable {
  int[] data = new int[5];

  @Override
  protected Object clone() throws CloneNotSupportedException {
      return super.clone();
  }
}

public void copyTest() {
    ShallowDummy shallowDummyFirst = new ShallowDummy();
    ShallowDummy shallowDummySecond = (ShallowDummy) shallowDummyFirst.clone();

    shallowDummySecond.data[0] = 100;

    System.out.println("shallowDummy First : " + shallowDummyFirst.data[0]);
    System.out.println("shallowDummy Second : " + shallowDummySecond.data[0]);
}

>>>결과
shallowDummy First : 100    // data hashCode : 1554874502
shallowDummy Second : 100   // data hashCode : 1554874502

```

- 깊은 복사
```java
class DeepDummy implements Cloneable {
    int[] data = new int[5];

    @Override
    protected Object clone() throws CloneNotSupportedException {
        DeepDummy dummy = (DeepDummy) super.clone();
        dummy.data = data.clone();  // data clone
        return dummy;
    }
}

public void copyTest() {
    DeepDummy deepDummyFirst = new DeepDummy();
    DeepDummy deepDummySecond = (DeepDummy) deepDummyFirst.clone();

    deepDummySecond.data[0] = 100;
    
    System.out.println("deepDummyFirst : " + deepDummyFirst.data[0]);
    System.out.println("deepDummySecond : " + deepDummySecond.data[0]);
}

>>>결과
deepDummyFirst : 0      // data hashCode : 1846274136
deepDummySecond : 100   // data hashCode : 1639705018
```
### 참고로 불변 객체나 배열이 아니라면 Clone 보다는 생성자 혹은 팩터리 방식으로 복사 하는게 좋다
```java

class DeepDummy  {
  Point p;
  
  // 생성자 방식
  public DeepDummy(DeepDummy oldDummy) {
      this.p.x = oldDummy.p.x;
      this.p.y = oldDummy.p.y;
  }
  
  // 팩터리 방식
  public static DeepDummy newInstance(DeepDummy oldDummy) {
      DeepDummy newDeepDummy = new DeepDummy();
      
      newDeepDummy.p.x = oldDummy.p.x;
      newDeepDummy.p.y = oldDummy.p.y;
      
      return newDeepDummy;
  }
}
```



<br></br>
## 아이템 51. 메서드 시그니처를 신중히 설계하라

<br></br>
## 아이템 52. 다중정의는 신중히 사용하라

<br></br>
## 아이템 53. 가변인수는 신중히 사용하라

<br></br>
## 아이템 54. null이 아닌, 빈 컬렉션이나 배열을 반환하라

<br></br>
## 아이템 55. 옵셔널 반환은 신중히 하라

<br></br>
## 아이템 56. 공개된 API 요소에는 항상 문서화 주석을 작성하라
