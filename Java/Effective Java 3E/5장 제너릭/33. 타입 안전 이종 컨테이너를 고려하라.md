## 타입 안전 이종(혼성) 컨테이너를 사용을 고려하라. (Type safe heterogeneous container pattern)

*컨테이너 : 객체를 저장하는 역할을 하는 클래스  
Collections(List, Set, Queue), Map, 배열 등

타입의 수에 제약없이 유연하게 필요한 경우 또는  
특정 타입 외에 다양한 타입을 지원해야 하는 경우가 있다.  
컨테이너 대신 키를 매개변수화 한 다음 컨테이너에 값을 넣거나, 뺄 때 키 타입을 제공해 주면 된다.  
이것이 타입 안전 이종(혼성) 컨테이너 패턴이다
class 들의 타입은 제네릭이다.  
ex)String.class == Class<String>  
메서드들이 주고받는 class 리터럴을 타입 토큰(type token)이라 한다.

타입 안전 이종(혼성) 컨테이너 패턴이다
```
public class Favorites {
    // class 리터럴이면 뭐든 넣을 수 있다.
    private Map<Class<?>, Object> favorites = new HashMap<>();

    public <T> void putFavorite(Class<T> type, T instance) {
        favorites.put(Objects.requireNonNull(type), instance);
    }

    public <T> T getFavorite(Class<T> type) {
        return type.cast(favorites.get(type));
    }

    public static void main(String[] args) {
        Favorites f = new Favorites();
        f.putFavorite(String.class, "Java");
        f.putFavorite(Class.class, Favorites.class);

        String favoriteString = f.getFavorite(String.class);
        Class<?> favoriteClass = f.getFavorite(Class.class);

        // 출력 결과: Java Favorites
        System.out.printf("%s %s%n", favoriteString, favoriteClass.getName());
    }
}
```

이종(혼성) 컨테이너를 Map 으로 구현 할 경우 타입 안전이 보장되지 않는다. (컴파일 단계에서 에러를 찾지 못함)
```
Map<Class, Object> map = new HashMap<Class, Object>();
map.put(String.class, 3);   // 3 이 String이 아니지만 컴파일 통과

String str = (String) map.get(String.class);    // ClassCastException
```

오류 발생 가능성
```
f.putFavorite((Class)Integer.class, "This is not integer !!!");
Integer notInteger = f.getFavorite(Integer.class); // ClassCastException
```

실체화가 불가능한 타입은 넣을 수 없다(List<String> 등). 해결하려면 슈퍼 타입 토큰 사용
  
```
List<String> pets = Arrays.asList("강아지", "고양이");
f.putFavorite(new TypeRef<List<String>>(){}, pets);
List<String> list = f.getFavorite(new TypeRef<List<String>>(){});
```
