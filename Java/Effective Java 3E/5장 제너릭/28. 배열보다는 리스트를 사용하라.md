## 배열보다는 리스트를 사용하라

### 배열과 제릭 타입의 차이

#### 1. 공변(covariant) vs 비공변(invariant)

배열은 공변(covariant)
>공변(covariant) : Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입

제너릭은 불공변(invariant)
>List<Type1> 은 List<Type2> 의 하위 타입도 아니고 상위 타입도 아니다.

*배열의 문제점

런타임에서 에러 발생 (배열)
```
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없다";  // ArrayStoreException
```

컴파일에서 에러 발생 (제너릭)
```
List<Object> ol = new ArrayList<Long>();  // 호환되지 않음
ol.add("타입이 달라 넣을 수 없다");
```

*제너릭을 사용하면 컴파일 단계에서 에러 잡을 수 있다.

#### 2. 배열은 실체화(reify) 된다.
>배열 : 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다.  
제너릭 : 타입 정보가 런타임에서는 소거(erasure) 된다.

Ex) 제너릭 소거  
List<Integer> 런타임에서는 List  
List<Integer<[] 런타임에서는 List[]

*제너릭의 소거는 자바5 에서 하위 호환성을 위해 사용됨.

제너릭 배열 생성은 허용하지 않는다. 아래는 허용하지 않는 이유 예시.
```
List<String>[] stringLists = new List<String>[1];  // (1) 
List<Integer> intList = List.of(42);               // (2) 
Object[] objects = stringLists;                    // (3) 
objects[0] = intList;                              // (4)
String s = stringLists[0].get(0);                  // (5)
```

(1) 허용된다고 가정 해보자.

(2) 원소가 하나인 List<Integer> 생성

(3) 배열은 공변이니 문제 없음. (List<StringL>[] -> Object[])

(4) List<Integer> 인스턴스를 Object배열 첫 원소로 저장. 제너릭은 런타임에서 타입 정보가 소거 되므로 성공.

(5) stringLists[0].get(0) 의 원소는 Integer 이므로 런타임에서 ClassCastException 발생

따라서, 제너릭 배열이 생성되지 않도록 (1)에서 컴파일 오류를 내야 한다.



