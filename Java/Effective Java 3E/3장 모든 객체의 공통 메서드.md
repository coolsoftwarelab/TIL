# 3장 모든 객체의 공통 메서드

##  10. equals는 일반 규약을 지켜 재정의하라

다음 상황 중 하나에 해당한다면 재정의 하지 말 것

- 각 인스턴스가 본질적으로 고유하다.
- 인스턴스의 '논리적 동치성(logical equality)'을 검사할 일이 없다.
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
- 클래스가 private 이거나 package-private이고 equals 메서드를 호출할 일이 없다.

**핵심 정리**

꼭 필요한 경우가 아니면 equals를 재정의하지 말자.   
많은 경우에 Object의 equals가 여러분이 원하는 비교를 정확히 수행해준다.  
재정의해야 할 때는 그 클래스의 핵심 필드 모두를 빠짐없이, 다섯 가지 규약을 확실히 지켜가며 비교해야 한다.

## 아이템 11. equals를 재정의하려거든 hashCode도 재정의하라

**equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다.**

hashCode() : 주소값을 기반으로 생성된 정수값을 리턴.
(주소값이 같은 객체는 hashCode도 동일하다)  
두 객체가 같은 객체인지 확인할 때 사용한다.  
논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.

최악의 (하지만 적법한) hashCode 구현 - 사용 금지!
```java
@Override public int hashCode() { return 42; }
```

전형적인 hashCode 메서드
```java
@Override public int hashCode() { 
  int result = Short.hashCode(areaCode)
  result = 31 * result Short.hashCode(prefix);
  result = 31 * result Short.hashCode(lineNum);
  return result; 
}
```

왜 31 인가?
=>Hash 했을 때 충돌이 가장 적은 숫자.
>31은 **소수이면서 홀수**이기 때문에 선택된 값이다. 만일 그 값이 짝수였고 곱셈 결과가 오버플로되었다면 정보는 사라졌을 것이다. 2로 곱하는 것은 비트를 왼쪽으로 shift하는 것과 같기 때문이다. 소수를 사용하는 이점은 그다지 분명하지 않지만 전통적으로 널리 사용된다. 31의 좋은 점은 곱셈을 시프트와 뺄셈의 조합으로 바꾸면 더 좋은 성능을 낼 수 있다는 것이다(31 * i는 (i « 5) - i 와 같다). 최신 VM은 이런 최적화를 자동으로 실행한다.

한 줄짜리 hashCode 메서드 - 성능이 살짝 아쉽다.
```java
@Override public int hashCode() {
  return Objects.hash(lineNum, prefix, areaCode); 
}
```

해시코드를 지연 초기화하는 hashCode 메서드 - 스레드 안정성까지 고려해야 한다.
```java
private int hashCode;

@Override public int hashCode() { 
  int result = hashCode;
  if(result == 0) {
    result = Short.hashCode(areaCode)
    result = 31 * result Short.hashCode(prefix);
    result = 31 * result Short.hashCode(lineNum);
    hashCode = result
  }
  return result; 
}
```

**핵심정리**  
equals를 재정의할 때는 hashCode도 반드시 재정의해야 한다.  
재정의한hashCode는 Object의 API 문서에 기술된 일반 규약을 따라야 하며,  
서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 한다.

https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--

-----


string 객체는 서로 다른 객체도 문자열이 같으면 hashCode가 동일하다. (해시 테이블의 성능)

equals()가 true 이면 hashCode()도 true가 되어야 한다.

## 아이템12. toString을 항상 재정의하라

Object의 기본 toString 메서드는 예를들면  
PhoneNumber@adbbd 처럼 단순히 '클래스이름@16진수로표시한해시코드' 를 반환할 뿐이다.  
toString()의 일반 규약에 따르면 '간결하면서 사람이 읽기 쉬운 형태의 유익한 정보'를 반환해야 한다.  
010-1234-5678 처럼 전화번호를 직접 알려주는 형태가 유익한 정보일 것이다.

```java
@Override public String toString() {
  return String.format("%03d-%03d-%04d",
     areaCode, prefix, lineNum);
}
```

## 아이템 13. clone 재정의는 주의해서 진행하라

새로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안되며, 새로운 클래스도 이를 구현해서는 안 된다.

final 클래스라면 Cloneable을 구현해도 위험이 크지 않지만, 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 드물게 허용해야 한다. 기본 원칙은 '복제 기능은 생성자와 팩터리를 이용하는 게 최고'라는 것이다. 단, 배열만은 clone 메서드 방식이 가장 깔끔하고, 이 규칙의 합당한 예외로 볼 수 있다.

## 아이템 14. Comparable 을 구현할지 고려하라

Comparable 인터페이스의 메소드 compareTo 하나이다.  
equals와 비슷하지만 단순 동치성 비교외에 순서 비교와 제너릭의 특성을 가진다.  
Comparable을 구현했다는 것은 그 클래스의 인스턴드들에는 자연적인 순서가 있음을 뜻한다.

**알파벳, 숫자 , 연대 같이 순서가 명확한 값 클래스를 작성한다면 반드시 Comparable 인터페이스를 구현하자.**

-----
**compareTo의 규약**

1. 이 객체와 주어진 객체의 순서를 비교한다.

2. 이 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 반환한다.

3. 이 객체와 비교할 수 없는 타입의 객체가 주어지면 ClassCastException을 던진다.

4. 두 객체 참조의 순서를 바꿔서 비교해도 예상한 결과가 나와야 한다.

5. 첫번째 객체가 두번째 객체보다 크고, 두번째 객체가 3번째 객체가 크면, 첫번째 객체는 세번째 객체보다 커야한다.

6. 크기가 같은 객체들 끼리는 어떤 객체와 비교하더라도 항상 같아야 한다.

7. (권장) compareTo의 동치성 결과가 equals와 같아야 한다.
-----

equals 와 비교해서 compareTo는 타입이 다른 객체를 신경쓰지 않아도 된다. (ClassCastException 을 던지면 되기 때문)

compareTo 메서드에서 관계 연산자 '<' 와 '>' (등호) 를 사용하는 이전 방식은 거추장스럽고 오류를 유발한다.  
대신 Integer.compare, Double.compare 등을 사용하라.

Comparable을 구현하지 않은 필드나 표준이 아닌 순서로 비교해야 한다면 비교자(Comparator)를 대신 사용한다.

**Comparator**  
자바 8에서는 FOMPARATOR 인터페이스가 일련의 비교자 생성 메서드와 팀을 꾸려 메서드 연쇄 방식으로 비교자를 생성할 수 잇게 되었다.  
대신 약간의 성능저하가 있다. (약 10%)

```java
private static final Comparator<PhoneNumber> COMPARATOR =
        comparingInt((PhoneNumber pn) -> pn.areaCode)
                .thenComparingInt(pn -> pn.prefix)
                .thenComparingInt(pn -> pn.lineNum);

public int compareTo(PhoneNumber pn) {
    return COMPARATOR.compare(this, pn);
}
```

**핵심정리**  
순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여, 그 인스턴스를 쉽게 정렬하고, 검색하고,
비교 기능을 제공하는 컬렉션과 어우러지도록 해야 한다.  compareTo 메서드에서 필드의 값을 비교할 때 < > 연산자는 쓰지 말아야 한다.  
그 대신 박싱된 기본 타입 클래스가 제공하는 정적 compare ㅁ서드나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자.


etc.
```java
public class MessageVO implements Comparable<MessageVO> {

    private String text;
    private Bitmap img;
    private long date;

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public Bitmap getImg() {
        return img;
    }

    public void setImg(Bitmap img) {
        this.img = img;
    }

    public long getDate() {
        return date;
    }

    public void setDate(long date) {
        this.date = date;
    }

    @Override
    public int compareTo(MessageVO o) {
        if (this.date > o.getDate()) {
            return -1;
        } else if (this.date < o.getDate()) {
            return 1;
        }
        return 0;
    }
}
```
