# 2장 객체 생성과 파괴

## 1. 생성자 대신 정적 팩터리 메서드를 고려하라

> 생성자 대신 정적 팩터리 메서드를 고려하라. (static factory method)  
참고로 디자인 패턴에서의 팩터리 메서드 패턴과는 다르다.

Ex1)
```
class Car {
  int horsepower;
  int torque;

  public Car(int horsepower, int torque) {
    this.horsepower = horsepower;
    this.torque = torque;
  }
  
  public static Car createTruck() {
    return Car(500, 250);
  }

  public static Car createSportsCar() {
    return Car(1000, 500);
  }
}
```

```
// 생성자를 이용
Car truck = new Car(500, 250);
Car sportsCar = new Car(1000, 500);
```

```
// 정적 팩터리 메서드
Car truck = Car.createTruck();
Car sportsCar = Car.createSportsCar();
```

Ex)2
```
public static Boolean valueOf(boolean b) {
  return b ? Boolean.TRUE : Boolean.FALSE;
}
```

### 장점

1. 이름을 가질 수 있다.
2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

### 단점

1. 상속을 하려면 public 이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

### 핵심 정리

>정적 팩터리 메서드와 public 생성자는 각자 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋다.  
그렇다고 하더라도 정적 팩터리를 사용하는게 유리한 경우가 더 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고치자.


## 2. 생성자에 매개변수가 많다면 빌더를 고려하라

정적 팩터리와 생성자에는 똑같은 제약이 하나 있다. 선택적 매개변수가 많을 때 적절히 대응하기 어렵다는 점이다.

```
Person p = new Person("홍길동", 180, 20, 111, 222, 333, ...)
```

점층적 생성자 패턴을 쓸 수는 있지만, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다.

자바빈즈 패턴에서는 객체 하나를 만들려면 메서드를 여러 개 호출해야 하고, 객체가 완전히 생성되기 전까지는 일관성(consistency)이 무너진 상태에 놓이게 된다.


빌더 사용 예
```
class Person {
    private final String name;
    private final int tall;
    private final int weight;

    private Person(Builder builder) {
        name = builder.name;
        tall = builder.tall;
        weight = builder.weight;
    }

    public static class Builder {
        private String name = "";
        private int tall = 0;
        private int weight = 0;

        // 필수 인자
        public Builder(String name) {
            this.name = name;
        }

        public Builder tall(int tall) {
            this.tall = tall;
            return this;        // 메서드 체이닝을 위해 사용
        }

        public Builder weight(int weight) {
            this.weight = weight;
            return this;
        }

        public Person build() {
            return new Person(this);
        }
    }
}
```

```
public static void main(String[] args) {
    Person p = new Person.Builder("홍길동")
            .tall(180)
            .weight(70)
            .build();
}
```

## 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라

클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.

```
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();
    
    private Elvis() {}
    
    public static Elvis getInstance() { return INSTANCE; }
    
    public void showMsg() { System.out.println("hello world"); }
}
```

```
Elvis.getInstance().showMsg();
```


대부분의 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.
```
public enum Elvis {
    INSTANCE;   // 암묵적 public static final Elvis INSTANCE = new Elvis();

    public void showMsg() {
        System.out.println("hello world");
    }
}
```

```
Elvis.INSTANCE.showMsg();
```

## 4. 인스턴스화를 막으려거든 private 생성자를 사용하라

private 생성자를 추가하면 클래스의 인스턴스화와 상속을 막을 수 있다.

```
// Noninstantiable utility class
public class UtilityClass {
    // Suppress default constructor for noninstantiability
    private UtilityClass() {
        throw new AssertionError();
    }
}
```

## 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

>클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이다 좋다.  
이 자원들을 클래스가 직접 만들게 해서도 안 된다.  
대신 필요한 자원을 (혹은 그 자원을 만들어주는 팩터리를) 생성자에 (혹은 정적 팩터리나 빌더에) 넘겨주자. 의존 객체 주입이라 하는 이 기법은 클래스의 유연성, 재사용성, 테스트 용이성을 개선해준다.

#### static 유틸 클래스

```
// 부적절한 static 유틸리티 사용 예 - 유연하지 않고 테스트 할 수 없다.
public class SpellChecker {

    private static final Lexicon dictionary = new KoreanDicationry();

    private SpellChecker() {
        // Noninstantiable
    }

    public static boolean isValid(String word) {
        throw new UnsupportedOperationException();
    }


    public static List<String> suggestions(String typo) {
        throw new UnsupportedOperationException();
    }
}

interface Lexicon {}

class KoreanDicationry implements Lexicon {}
```

#### 싱글톤

```
// 부적절한 싱글톤 사용 예 - 유연하지 않고 테스트 할 수 없다.
public class SpellChecker {

    private final Lexicon dictionary = new KoreanDicationry();

    private SpellChecker() {
    }

    public static final SpellChecker INSTANCE = new SpellChecker() {
    };

    public boolean isValid(String word) {
        throw new UnsupportedOperationException();
    }


    public List<String> suggestions(String typo) {
        throw new UnsupportedOperationException();
    }
}
```

## 의존성 주입을 활용한 구현

```
public class SpellChecker {

    private final Lexicon dictionary;

    public SpellChecker(Lexicon dictionary) {
        this.dictionary = Objects.requireNonNull(dictionary);
    }

    public boolean isValid(String word) {
        throw new UnsupportedOperationException();
    }
    
    public List<String> suggestions(String typo) {
        throw new UnsupportedOperationException();
    }

}

class Lexicon {}
```

대거, 쥬스, 스프링 등의 프레임워크를 이용해서 관리할 수도 있다. 


## 6. 불필요한 객체 생성을 피하라

불필요한 객체 생성
```
String s = "bikini";
String s = new String("bikini"); // 불필요한 객체 생성
```

정적 팩터리 메서드
```
static boolean isRomanNumeral(String s) {
    return s.matches("^(?=.)M*(C[MD] | D?C{0,3})"
        + "(X{CL] | L?X{0,3})(I[XV] | V?I{0,3})$");
}
```
위 코드를 개선
```
public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile(
        "^(?=.)M*(C[MD] | D?C{0,3})"
        + "(X[CL}|L?X{0,3})(I[XV]|V?I{0,3})$");
        
    static boolean isRomanNumeral(String s) {
        return ROMAN.matcher(s).matches();
    }
}
```
정규표현식을 표현하는 Pattern 인스턴스를 초기화과정에서 직접 생성해 캐싱해두고, 나중에 isRomanNumeral 메서드가 호출될 때마다 재사용한다.  
성능이 개선 전보다 약 6.5배 빨라진다.

오토 박싱 주의
```
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    return sum;
}
```
sum 이 long이 아닌 Long으로 불필요한 오토박싱 발생.  
박싱된 기본 타입보다는 기본타입을 사용하고, 의도치 않은 오토 박싱은 없는지 주의


## 7. 다 쓴 객체 참조를 해제하라

```
public Object pop() {
  if(size == 0)
    throw new EmptyStackException();
  Object result = elements[--size];
  elements[size] = null;  // 다 쓴 참조 해제
  return result;
}
```

## 8. finalizer와 cleaner 사용을 피하라

finalizer 는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다.

cleaner는 finalizer보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.


## 9. try-finally 보다는 try-with-resources 를 사용하라

try-finally
```
File file = new File("some where");
FileInputStream fis = null;
FileOutputStream fos = null;
try {
   fis = new FileInputStream(file);
   byte[] buf = new byte[1024];
   int tmp = fis.read(buf);

   fos = new FileOutputStream(file);
   fos.write(buf);
   fos.flush();
} catch (IOException e) {
   e.printStackTrace();
} finally {
   try { fis.close(); } catch (IOException e) { e.printStackTrace(); }
   try { fos.close(); } catch (IOException e) { e.printStackTrace(); }
}
```

try-with-resources
```
File file = new File("some where");
try (FileInputStream fis = new FileInputStream(file);
    FileOutputStream fos = new FileOutputStream(file)){
    byte[] buf = new byte[1024];
    int tmp = fis.read(buf);
    fos.write(buf);
    fos.flush();
} catch (IOException e) {
    e.printStackTrace();
}
```


```
static String firstLineOfFiles(String path) throws IOException {
  try(BufferedReader br = new BufferedReader(new FileReader(path))) {
    return br.readLine();
  }
}
 ```


