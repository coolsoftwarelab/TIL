## 아이템 85. 자바 직렬화의 대안을 찾으라


<br></br>
## 아이템 86. Serializable을 구현할지는 신중히 결정하라
<br>

#### 직렬화(Serialization)란?

- 직렬화 : 객체를 바이트 스트림으로 인코딩
- 역직렬화 : 바이트 스트림으로부터 객체를 재구성

>인스턴스 직렬화는 클래스 선언에 `implements Serializable` 만 덧붙이면 가능.

<br></br>
`Sub` 클래스를 직렬화하는 예제
```java
public class Sub implements Serializable {
    private String a = "this is a";
    private int b = 1000;

    public void test() {
        System.out.println("test");
    }
}


public static void main(String[] args) {
        Sub sub = new Sub();
        File f = new File("C:\\Users\\Dann\\Downloads\\test.dat");
        
        try (FileOutputStream fos = new FileOutputStream(f);
             ObjectOutputStream oos = new ObjectOutputStream(fos);
        ) {
            oos.writeObject(sub);
            oos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
}
```

실행결과 
```
// test.dat 파일 내용
aced 0005 7372 0010 636f 6d2e 7465 7374
2e6b 686a 2e53 7562 0502 4ec7 9db7 d29d
0200 0249 0001 624c 0001 6174 0012 4c6a
6176 612f 6c61 6e67 2f53 7472 696e 673b
7870 0000 03e8 7400 0974 6869 7320 6973
2061

// txt파일로 변환결과
ы sr com.test.khj.SubN?롬? I bL at Ljava/lang/String;xp  ? 	this is a
```

#### 위와 같이 직렬화 자체는 간단하지만 이후에 관리비용이 매우크니 구현에 신중해야 한다.

## Serializable을 구현하면 발생할 수 있는 문제점

### 1. 릴리스한 뒤 수정하기 어렵다

- Serializable을 구현하면 직렬화 형태도 하나의 공개 API가 되기때문에 이후 계속해서 지원해야 한다
  - 예를들어 클래스에 필드가 추가되면 API도 수정해야한다

- 스트림 고유 식별자 `serial Version UID` (SUID) 를 직접 지정하지않으면 자동으로 값이 생성되고 이후에 해당 클래스가 수정되면 UID 값도 변경되어 호환성이 깨진다(역직렬화 실패)
  - 런타임에 `InvalidClassException` 발생

### 2. 버그와 보안 문제

- 역직렬화는 언어의 기본 매커니즘을 우회하는 객체 생성 기법(숨은 생성자)으로,  
  이 과정에서 불변식이 깨지고 허가되지 않은 접근에 쉽게 노출된다(아이템88)

### 3. 신버전을 배포할 때 테스트할 것이 늘어난다

- 직렬화 가능 클래스가 수정되면 신버전과 구버전 간에 직렬화와 역직렬화가 가능한지 검사해야한다

### 상속용 클래스, Interface 대부분은 Serializable을 구현하면 안된다.

- 기능 확장이 힘들다 : 직렬화-역직렬화를 항상 보장해야 하기때문

#### 내부 클래스는 직렬화를 구현하지 말아야 한다

- 내부 클래스는 바깥 인스턴스의 참조와 유효 범위 안의 지역변수 값들을 저장하기 위해 컴파일러가 생성한 필드들이 자동으로 추가되는데 이 필드들의 직렬화 형태는 분명하지 않다

<br></br>
## 아이템 87. 커스텀 직렬화 형태를 고려해보라

직렬화에 적합한 코드
```java
public class Name implements Serializable {
    /**
     * 성. null이 아니어야 함.
     * @serial
     */
     private final String lastName;
     
     /**
     * 이름. null이 아니어야 함.
     * @serial
     */
     private final String firstName;
     
    /**
     * 중간이름. 중간이름이 없다면 null.
     * @serial
     */
     private final String middleName;
}
```

직렬화에 적합하지 않은 예
```java
public final class StringList implements Serializable {
    private int size = 0;
    private Entry head = null;
    
    private static class Entry implements Serializable {
        String data;
        Entry next;
        Entry previous;
    }
    ...
}
```

- StringList.Entry 가 공개 API 가 되어 노출된다.
- 많은 공간을 차지한다
- 속도가 많이 느릴 수 있다
- 스택오버플로우를 일으킬 수 있다

합리적인 직렬화 형태
```java
public final class StringList implements Serializable {
    private transient int size = 0;
    private transient Entry head = null;

    // 이번에는 직렬화 하지 않는다.
    private static class Entry {
        String data;
        Entry next;
        Entry previous;
    }

    // 문자열을 리스트에 추가한다.
    public final void add(String s) { ... }

    /**
     * StringList 인스턴스를 직렬화한다.
     */
    private void writeObject(ObjectOutputStream stream)
            throws IOException {
        stream.defaultWriteObject();
        stream.writeInt(size);

        // 모든 원소를 순서대로 기록한다.
        for (Entry e = head; e != null; e = e.next) {
            s.writeObject(e.data);
        }
    }

    private void readObject(ObjectInputStream stream)
            throws IOException, ClassNotFoundException {
        stream.defaultReadObject();
        int numElements = stream.readInt();

        for (int i = 0; i < numElements; i++) {
            add((String) stream.readObject());
        }
    }
    // ... 생략
}
```
- transient 키워드가 붙은 필드는 기본 직렬화 형태에 포함되지 않는다.
- 신버전의 인스턴스를 직렬화한 후에 구버전으로 역직렬화하면 새로 추가된 필드는 무시될 것이다
- 구버전 readObject 메서드에서 defaultReadObject를 호출하지 않는다면 역직렬화 과정에서 StreamCorruptedException이 발생한다.

기본 직렬화 사용 여부와 상관없이 직렬화에도 동기화 규칙을 적용해야 한다. 예를 들어 모든 메서드를 synchronized로 선언하여 스레드 안전하게 만든 객체에 기본 직렬화를 사용한다면, writeObject도 아래처럼 수정해야 한다.

```java
private synchronized void writeObject(ObjectOutputStream stream)
        throws IOException {
    stream.defaultWriteObject();
}
```

### SerialVersionUID

>직렬화가 가능한 클래스에는 SerialVersionUID(이하 SUID)를 명시적으로 선언해야 한다.

```java
private static final long serialVersionUID = 1234L;
```

#### SUID가 꼭 유니크할 필요는 없다. 다만 이 값이 변경되면 기존 버전 클래스와의 호환을 끊게 되는 것이다. 따라서 호환성을 끊는 경우가 아니라면 SUID 값을 변경해서는 안 된다.


<br></br>
## 아이템 88. readObject 메서드는 방어적으로 작성하라

아이템50 방어적 복사로 불변을 유지하는 클래스로 진행

해당 클래스에 Serializable 인터페이스를 구현하면 불변식을 보장하지 못한다

readObject 로 들어오는 바이트 스트림을 의도적으로 수정하거나 생성해서 공격할 가능성이 있다

이를 해결하려면 defaultReadObject() 호출 후 역직렬화 시 유효성검사를 해야한다  
(불변식이 만족하는지 검사)

더 좋은 방법은 객체를 역직렬화할 때는 클라이언트가 소유해서는 안 되는, 객체 참조를 갖는 필드들을 반드시 방어적으로 복사해야 한다.  
따라서 readObject에서는 불변 클래스 안의 모든 private 가변 요소를 방어적으로 복사해야 한다.

```java
private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
    s.defaultReadObject();

    // 가변 요소들을 방어적으로 복사한다.
    start = new Date(start.getTime());
    end = new Date(end.getTime());

    // 불변식을 만족하는지 검사한다.
    if(start.compareTo(end) > 0) {
        throw new InvalidObjectException(start + "가 " + end + "보다 늦다.");
    }
}
```


<br></br>
## 아이템 89. 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라


<br></br>
## 아이템 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라



 1
