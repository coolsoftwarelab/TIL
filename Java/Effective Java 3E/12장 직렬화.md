## 아이템 85. 자바 직렬화의 대안을 찾으라


<br></br>
## 아이템 86. Serializable을 구현할지는 신중히 결정하라
<br>

## Serializable을 구현 시 발생할 수 있는 문제점

### 1. 릴리스한 뒤 수정하기 어렵다

- 직렬화된 바이트 스트림 인코딩도 하나의 공개 API가 되기때문에 영원히 지원해야 한다
- 자바 기본 방식의 직렬화 형태를 사용하면 `private`와 `package-private` 인스턴스 필드들은 공개된다
- 클래스 내부 구현을 뒤늦게 변경하면 원래 배포한 직렬화 형태와 달라지기 때문에 역직렬화에 실패할 수 있다
- 스트림 고유 식별자 UID(serial Version UID) 를 직접 지정하지않으면 자동으로 값이 생성되고 이후에 해당 클래스가 수정되면 UID 값도 변경되어 호환성이 깨진다
  - 런타임에 `InvalidClassException` 발생

### 2. 버그와 보안 문제

- 직렬화 가능 클래스가 수정되면 신버전과 구버전 간에 직렬화와 역직렬화가 가능한지 검사해야한다

### 3. 신버전을 배포할 때 테스트할 것이 늘어난다

- 직렬화는 언어의 기본 매커니즘을 우회하는 객체 생성 기법이다(숨은 생성자)
- 기본 역직렬화를 사용하면 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출된다 (아이템88)

### 상속용으로 설계된 클래스 대부분은 Serializable을 구현하면 안된다.

### 인터페이스도 대부분 Serializable을 확장해서는 안 된다.

### 내부 클래스는 직렬화를 구현하지 말아야 한다


<br></br>
## 아이템 87. 커스텀 직렬화 형태를 고려해보라

직렬화에 적합한 코드
```java
public class Name implements Serializable {
    /**
     * 성. null이 아니어야 함.
     * @serial
     */
     private final String lastName;
     
     /**
     * 이름. null이 아니어야 함.
     * @serial
     */
     private final String firstName;
     
    /**
     * 중간이름. 중간이름이 없다면 null.
     * @serial
     */
     private final String middleName;
}
```

직렬화에 적합하지 않은 예
```java
public final class StringList implements Serializable {
    private int size = 0;
    private Entry head = null;
    
    private static class Entry implements Serializable {
        String data;
        Entry next;
        Entry previous;
    }
    ...
}
```

- StringList.Entry 가 공개 API 가 되어 노출된다.
- 많은 공간을 차지한다
- 속도가 많이 느릴 수 있다
- 스택오버플로우를 일으킬 수 있다

합리적인 직렬화 형태
```java
public final class StringList implements Serializable {
    private transient int size = 0;
    private transient Entry head = null;

    // 이번에는 직렬화 하지 않는다.
    private static class Entry {
        String data;
        Entry next;
        Entry previous;
    }

    // 문자열을 리스트에 추가한다.
    public final void add(String s) { ... }

    /**
     * StringList 인스턴스를 직렬화한다.
     */
    private void writeObject(ObjectOutputStream stream)
            throws IOException {
        stream.defaultWriteObject();
        stream.writeInt(size);

        // 모든 원소를 순서대로 기록한다.
        for (Entry e = head; e != null; e = e.next) {
            s.writeObject(e.data);
        }
    }

    private void readObject(ObjectInputStream stream)
            throws IOException, ClassNotFoundException {
        stream.defaultReadObject();
        int numElements = stream.readInt();

        for (int i = 0; i < numElements; i++) {
            add((String) stream.readObject());
        }
    }
    // ... 생략
}
```
- transient 키워드가 붙은 필드는 기본 직렬화 형태에 포함되지 않는다.
- 신버전의 인스턴스를 직렬화한 후에 구버전으로 역직렬화하면 새로 추가된 필드는 무시될 것이다
- 구버전 readObject 메서드에서 defaultReadObject를 호출하지 않는다면 역직렬화 과정에서 StreamCorruptedException이 발생한다.

기본 직렬화 사용 여부와 상관없이 직렬화에도 동기화 규칙을 적용해야 한다. 예를 들어 모든 메서드를 synchronized로 선언하여 스레드 안전하게 만든 객체에 기본 직렬화를 사용한다면, writeObject도 아래처럼 수정해야 한다.

```java
private synchronized void writeObject(ObjectOutputStream stream)
        throws IOException {
    stream.defaultWriteObject();
}
```

### SerialVersionUID

>직렬화가 가능한 클래스에는 SerialVersionUID(이하 SUID)를 명시적으로 선언해야 한다.

```java
private static final long serialVersionUID = 1234L;
```

#### SUID가 꼭 유니크할 필요는 없다. 다만 이 값이 변경되면 기존 버전 클래스와의 호환을 끊게 되는 것이다. 따라서 호환성을 끊는 경우가 아니라면 SUID 값을 변경해서는 안 된다.


<br></br>
## 아이템 88. readObject 메서드는 방어적으로 작성하라


<br></br>
## 아이템 89. 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라


<br></br>
## 아이템 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라



 1
