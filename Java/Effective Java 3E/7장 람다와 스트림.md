## 아이템 42. 익명 클래스보다는 람다를 사용하라

<br></br>
## 아이템 43. 람다보다는 메서드 참조를 사용하라

### 메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고 그렇지 않을 때만 람다를 사용해라.

ex 1)
```
// 람다
Arrays.asList(1, 2, 3, 4, 5)
        .forEach(i -> System.out.println(i));
        
// 메서드 참조
Arrays.asList(1, 2, 3, 4, 5)
        .forEach(System.out::println);
```

ex 2)
```
Arrays.asList(new BigDecimal("20.0"),
              new BigDecimal("30"),
              new BigDecimal("1.0"))
                .stream()
             // .sorted((bd1, bd2) -> bd1.compareTo(bd2)) // 람다
                .sorted(BigDecimal::compareTo)            // 메서드 참조
                .collect(toList());
```


람다가 메서드 참조보다 나은 경우
```
class GoshThisClassnameIsHumongous{
    ...
}

// 메서드 참조
service.execute(GoshThisClassnameIsHumongous::action);

// 람다
service.execute(() -> action());
```


### 메서드 참조의 유형

#### 1. 정적 메서드 참조 
>Integer::parseInt       // ClassName::staticMethodName

#### 2. 한정적(인스턴스) 메서드 참조 
>Instant.now()::isAfter  // instanceName::instanceMethodName

- 특정 인스턴스의 메서드를 참조. 한정적(bound)
- 함수 객체가 받는 인수와 참조되는 메서드가 받는 인수가 동일  

#### 3. 비한정적(인스턴스) 메서드 참조
>String::toLowerCase    // ClassName::instanceMethodName

- 나중에 전달받는 임의의 객체의 인스턴스 메서드 참조. 비한정적(unbound)
- 스트림 파이프 라인에서 주로 매핑과 필터 함수에 사용

#### 4. 클래스 생성자 
>TreeMap<K,V>::new      // ClassName::new

#### 5. 배열 생성자
>int[]::new             // ClassName::new


### 람다로는 제네릭 함수타입 구현을 표현할 수 없다. 메서드 참조로만 가능하다

```

    interface G1 {
        <E extends Exception> Object m() throws E;
    }

    interface G2 {
        <F extends Exception> String m() throws Exception;
    }
    
    interface G extends G1, G2 {}
    
    // 함수형 인터페이스 G를 함수 타입으로 표현
    // 제네릭 람다식이란 문법은 없다
    <F extends Exception> ()->String throws F
```

<br></br>
## 아이템 44. 표준 함수형 인터페이스를 사용하라

<br></br>
## 아이템 45. 스트림은 주의해서 사용하라

<br></br>
## 아이템 46. 스트림에서는 부작용 없는 함수를 사용하라

### 스트림은 함수형 프로그래밍에 기초한 패러다임

>각 변환 단계는 가능한 이전 단계의 결과를 받아 처리하는 `순수 함수` 여야 한다.

>순수함수 : 입력만이 결과에 영향을 주는 함수(다른 가변 상태 참조X, 함수 스스로도 다른 상태를 변경X)

스트림 패러다임에 안맞는 코드
```
// Uses the streams API but not the paradigm--Don't do this!
Map<String, Long> freq = new HashMap<>();
try (Stream<String> words = new Scanner(file).tokens()) {
  words.forEach(word -> {
      freq.merge(word.toLowerCase(), 1L, Long::sum);
    });
  }
```

종단 연산인 forEach 에서 외부 상태를 수정하는 람다를 실행하면서 문제가 생긴다. (side effect)

#### forEach 연산은 스트림 계산 결과를 보고할 때만 사용하라.

수정된 코드
```
Map<String, Long> freq;
try (Stream<String> words = new Scanner(file).tokens()) {
    freq = words
            .collect(groupingBy(String::toLowerCase, counting()));
}
```

### Collector 

>Collector 를 사용하면 스트림의 원소를 컬렉션으로 쉽게 모을 수 있다.

- toList() : 리스트 반환
- toSet() : 집합 반환
- toCollection(collectionFactory) : 프로그래머가 지정한 컬렉션 타입 반환

상위 10 개 단어 목록을 가져 오는 파이프 라인
```
List<String> topTen = freq.keySet().stream()
        .sorted(comparing(freq::get).reversed())
        .limit(10)
        .collect(toList());
```

Collector 예시
```
// List
list.stream().collect(Collectors.toList());

// set
list.stream().collect(Collectors.toSet());

// Map
list.stream().collect(Collectors.toMap("key", "val");

// toCollection
list.stream().collect(Collectors.toCollection(LinkedList::new));
```

<br></br>
## 아이템 47. 반환 타입으로는 스트림보다 컬렉션이 낫다




