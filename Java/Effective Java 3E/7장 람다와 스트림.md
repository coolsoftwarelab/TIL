## 아이템 42. 익명 클래스보다는 람다를 사용하라

익명 클래스의 인스턴스를 함수 객체로 사용 - 낡은 기법!
```java
Collections.sort(words, new Comparator<Stringf>() {
    public int compare(String s1, String s2) {
        return Intger.compare(s1.length(), s2.length());
    }
}
```

자바 8에와서 함수형 인터페이스(추상 메서드 하나짜리 인터페이스)의 인스턴스를 람다로 만들 수 있다.

람다식을 함수 객체로 사용 - 익명 클래스 대체
```java
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length());
```
매개변수와 반환값 타입은 컴파일러가 추론해준다.

#### 람다 단점
- 람다는 이름이 없고 문서화도 못한다. 코드 동작 설명이 명확하지 않고 코드 줄 수가 많아지면 람다를 쓰지 말아야한다.
- 람다는 길어야 세 줄 안에 끝내는게 좋다.
- 람다에서 `this` 키워드는 자기 자신을 가리키지 못하고 바깥 인스턴스를 가리킨다.
- 람다를 직렬화 하는 일은 하지말아야 한다. (익명 클래스 인스턴스도 마찬가지)



<br></br>
## 아이템 43. 람다보다는 메서드 참조를 사용하라

### 메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고 그렇지 않을 때만 람다를 사용해라.

ex 1)
```
// 람다
Arrays.asList(1, 2, 3, 4, 5)
        .forEach(i -> System.out.println(i));
        
// 메서드 참조
Arrays.asList(1, 2, 3, 4, 5)
        .forEach(System.out::println);
```

ex 2)
```
Arrays.asList(new BigDecimal("20.0"),
              new BigDecimal("30"),
              new BigDecimal("1.0"))
                .stream()
             // .sorted((bd1, bd2) -> bd1.compareTo(bd2)) // 람다
                .sorted(BigDecimal::compareTo)            // 메서드 참조
                .collect(toList());
```


람다가 메서드 참조보다 나은 경우
```
class GoshThisClassnameIsHumongous{
    ...
}

// 메서드 참조
service.execute(GoshThisClassnameIsHumongous::action);

// 람다
service.execute(() -> action());
```


### 메서드 참조의 유형

#### 1. 정적 메서드 참조 
>Integer::parseInt       // ClassName::staticMethodName

#### 2. 한정적(인스턴스) 메서드 참조 
>Instant.now()::isAfter  // instanceName::instanceMethodName

- 특정 인스턴스의 메서드를 참조. 한정적(bound)
- 함수 객체가 받는 인수와 참조되는 메서드가 받는 인수가 동일  

#### 3. 비한정적(인스턴스) 메서드 참조
>String::toLowerCase    // ClassName::instanceMethodName

- 나중에 전달받는 임의의 객체의 인스턴스 메서드 참조. 비한정적(unbound)
- 스트림 파이프 라인에서 주로 매핑과 필터 함수에 사용

#### 4. 클래스 생성자 
>TreeMap<K,V>::new      // ClassName::new

#### 5. 배열 생성자
>int[]::new             // ClassName::new


### 람다로는 제네릭 함수타입 구현을 표현할 수 없다. 메서드 참조로만 가능하다

```

    interface G1 {
        <E extends Exception> Object m() throws E;
    }

    interface G2 {
        <F extends Exception> String m() throws Exception;
    }
    
    interface G extends G1, G2 {}
    
    // 함수형 인터페이스 G를 함수 타입으로 표현
    // 제네릭 람다식이란 문법은 없다
    <F extends Exception> ()->String throws F
```

<br></br>
## 아이템 44. 표준 함수형 인터페이스를 사용하라
>필요한 용도에 맞는게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라 (java.util.function)

### 기본 함수형 인터페이스
인터페이스 | 함수 시그니처 | 특징 | 예시 | 
--- | --- | --- | --- |
UnaryOpertator<T> | T apply(T t) | 반환값과 인수의 타입이 같은 함수, 인수는 1개 | String::toLowerCase |
binaryOpertation<T> | T apply(T t1, T t2) | 반환값과 인수의 타입이 같은 함수, 인수는 2개 | BigInteger::add |
Predicate<T> | boolean test(T t) | 인수 하나를 받아 boolean 반환 | Collection::isEmpty |
Fuction<T,R> | R apply(T t) | 인수 반환 타입이 다름 | Arrays:asList |
Supplier<T> | T get() | 인수를 받지않고 값을 반환(혹은 제공) | Intant::now |
Consumer<T> | void apccept(T t) | 인수 하나를 받고 반환값이 없는 함수(특히 인수를 소비) | System.out::println |
   
- 표준 함수형 인터페이스 대부분은 기본 타입만 지원
- 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지마라
    
### 직접 만든 함수형 인터페이스는 항상 `@FunctionalInterface` 애너테이션을 사용하라    
    
예시
```java
@FunctionalInterface
interface Display {
    void show(String str);
}

main() {
    Display display = str -> System.out.println(str);
    display.show("hello");
}
```
    
#### `@FunctionalInterface` 애너테이션을 다는 이유
- 인터페이스가 람다용으로 설계된 것을 알려줌
- 유지보수과정에서 실수로 메서드가 추가되는 것을 막아준다  
(함수형 인터페이스에서 추상 메서드는 오직 하나여야함)

<br></br>
## 아이템 45. 스트림은 주의해서 사용하라

<br></br>
## 아이템 46. 스트림에서는 부작용 없는 함수를 사용하라

### 스트림은 함수형 프로그래밍에 기초한 패러다임

>각 변환 단계는 가능한 이전 단계의 결과를 받아 처리하는 `순수 함수` 여야 한다.

>순수함수 : 입력만이 결과에 영향을 주는 함수(다른 가변 상태 참조X, 함수 스스로도 다른 상태를 변경X)

스트림 패러다임에 안맞는 코드
```
// Uses the streams API but not the paradigm--Don't do this!
Map<String, Long> freq = new HashMap<>();
try (Stream<String> words = new Scanner(file).tokens()) {
  words.forEach(word -> {
      freq.merge(word.toLowerCase(), 1L, Long::sum);
    });
  }
```

종단 연산인 forEach 에서 외부 상태를 수정하는 람다를 실행하면서 문제가 생긴다. (side effect)

#### forEach 연산은 스트림 계산 결과를 보고할 때만 사용하라.

수정된 코드
```
Map<String, Long> freq;
try (Stream<String> words = new Scanner(file).tokens()) {
    freq = words
            .collect(groupingBy(String::toLowerCase, counting()));
}
```

### Collector 

>Collector 를 사용하면 스트림의 원소를 컬렉션으로 쉽게 모을 수 있다.

- toList() : 리스트 반환
- toSet() : 집합 반환
- toCollection(collectionFactory) : 프로그래머가 지정한 컬렉션 타입 반환

상위 10 개 단어 목록을 가져 오는 파이프 라인
```
List<String> topTen = freq.keySet().stream()
        .sorted(comparing(freq::get).reversed())
        .limit(10)
        .collect(toList());
```

Collector 예시
```
// List
list.stream().collect(Collectors.toList());

// set
list.stream().collect(Collectors.toSet());

// Map
list.stream().collect(Collectors.toMap("key", "val");

// toCollection
list.stream().collect(Collectors.toCollection(LinkedList::new));
```

<br></br>
## 아이템 47. 반환 타입으로는 스트림보다 컬렉션이 낫다




