## 아이템 69. 예외는 진짜 예외 상황에만 사용하라
<br>

### 예외는 오직 예외 상황에서만 써야한다. 절대 일상적인 제어 흐름용으로 사용해선 안된다
<br>

표준 관용구(일반적인 코드)
```java
for (Mountain m : range) {
    m.climb();
}
```
<br>

위 코드를 변형해서 무한루프를 돌다가 배열 끝에 도달하면 예외를 발생시키고 끝내는 코드 - 문제있음!
```java
try {
    int i = 0;
    while(true) {
        range[i++].climb();
    }
} catch (ArrayIndexOutOfBoundsException e) { }
```
### 위와 같이 예외를 써서 루프를 종료한 이유는?
=>예외를 이용하면 성능이 좋아질 것이라는 잘못된 추론으로 인해 만들어진 코드이다.
```
JVM은 배열 인덱스가 사용될 때마다 경계를 넘지 않는지 검사한다(경계검사)
일반적인 반복문도 경계검사를 한다

즉 위 코드는 for문을 사용할 때와 배열에 접근할 때 중복으로 경계 검사를 한다고 잘못된 추론을 해서
예외를 통한 loop로 반복문의 경계검사를 제거해 성능 향상을 시키려는 시도이다.
```

- 배열을 순회하는 표준 관용구는 배열 경계 중복 검사를 수행하지 않는다. JVM이 알아서 최적화해서 없애준다.
  - 그러므로 예외를 써서 루프를 종료할 이유가 없다

- 예외는 예외 상황에 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 최적화에 신경쓰지 않았을 확률이 높다.

- 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.


<br>

#### 잘못된 예외상황 적용 코드의 문제점

- 표준 관용구를 사용 할 때보다 성능이 떨어진다.

- 버그를 숨겨 디버깅을 어렵게 만든다.
  - 반복문안에서 호출한 메서드가 내부에서 관련 없는 배열을 사용하다가, `ArrayIndexOutOfBoundsException`이 발생해도  
    정상적인 반복문 종료상황으로 넘어간다. 표준 관용구였다면 이 버그는 스레드를 즉각 종료시킬 것이다.
<br>

### 잘 설계된 API란?

- 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.
- '상태 의존적' 메소드를 제공하는 클래스는 '상태 검사' 메서드도 함께 제공해야 한다.  

Iterator 표준 관용구 사용
```java
for(Iterator<Foo> i = collection.iterator(); i.hashNext();) {
  Foo foo = i.next();
  ...
}
```
- `hasNext()` 상태 검사 메서드
- `next()` 상태 의존적 메서드

#### 만약 Iterator가 hasNext() 를 제공하지 않았다면?
=>그 일을 클라이언트가 대신해야 한다

```java
try {
  Iterator<Foo> i = collection.iterator();
  while(true) {
    Foo foo = i.next();
    ...
  }
} catch(NoSuchElementException e) { }
```
이 코드는 앞서 문제가 있던 예제 코드와 비슷하다. 반복문에 예외를 사용하면 속도도 느리고 버그가 발생하면 찾기 힘들다
<br>

### 상태 검사 메서드 사용 외에 방법

1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 null 같은 특정 값을 사용한다.
   - 상태 검사 메소드와 상태 의존적 메소드 호출 사이에 객체의 상태가 변할 수 있기 때문이다.
   
2. 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메소드의 작업 일부를 중복 수행한다면 옵셔널이나 null 같은 특정 값을 사용한다.

3. 그 외 다른 경우에는 상태 검사 메소드 를 사용하는 것이 낫다.
<br>

>다시 한번 정리하자면,  
예외는 예외 상황에서 쓸 의도로 설계되었으므로 제어 흐름에 사용해선 안된다.

<br></br>
## 아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

<br></br>
## 아이템 71. 필요 없는 검사 예외 사용은 피하라

<br></br>
## 아이템 72. 표준 예외를 사용하라

<br></br>
## 아이템 73. 추상화 수준에 맞는 예외를 던지라

<br></br>
## 아이템 74. 메서드가 던지는 모든 예외를 문서화하라

### 검사 예외

- 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 javadoc의 @throw 태그를 사용하여 정확히 문서화 하자
- 공통 상위 클래스 하나로 뭉뚱그려 선언하는 일은 삼가자

정확히 무슨 에러가 발생할 지 알 수 없다
```java
private void test1() throws Exception { ... }

public void test2() throws Throwable { ... }
```

올바른 사용
```java
private void test() throws IllegalStateException { ... }
```
-  단, main 함수는 JVM만이 호출하므로 Exception을 던져도 괜찮다.

### 비검사 에외

- 메서드가 던질수있는 예외를 @throws 태그로 문서화하되 비검사 예외는 메서드 선언의 throws 목록에 넣지는 말자.

```java
@throws UnCheckedException
@throws CheckedException
void someMethod throws CheckedException { ... } //검사예외만 작성하라 

```








<br></br>
## 아이템 75. 예외의 상세 메시지에 실패 관련 정보를 담으라
// todo

<br></br>
## 아이템 76. 가능한 한 실패 원자적으로 만들라

<br></br>
## 아이템 77. 예외를 무시하지 말라
