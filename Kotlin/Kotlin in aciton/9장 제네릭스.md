## 9.1 제네릭 타입 파라미터
>코틀린은 반드시 제네릭 타입의 타입 인자를 정의해야한다는 규약이 있다.


### 9.1.1 제네릭 함수와 프로퍼티
>리스트를 다루는 함수를 작성한다면 어떤 특정 타입을 저장하는 리스트뿐 아니라 모든 리스트를 다룰 수 있는 함수를 원할 것이다.  
이럴때 제네릭 함수를 작성해야 한다.

```
>>> val letters = ('a'..'z').toList()
>>> println(letters.slice<Char>(0..2)) // 타입 인자를 명시적으로 지정한다. 
[a, b, c]
>>> println(letters.slice(10..13)) // 컴파일러는 여기서 T가 Char라는 사실을 추론한다. 
[k, l, m, n]
```

### 9.1.2 제네릭 클래스 선언

자바와 마찬가지로 꺽쇠 기호(<>)를 사용하여 클래스나 인터페이스를 제네릭하게 만들 수 있다.

일반적으로 자바에서의 제네릭과 코틀린의 제네릭은 큰 차이가 없다.

### 9.1.3 타입 파라미터 제약

클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능

가령 모든 원소의 합을 구하려고 했을 때 List<Int>와 List<Double>은 사용하는데 문제가 없지만, List<String>의 경우 문제가 될 수 있다.

이 경우 타입 파라미터로 숫자 타입 만을 허용하게 하여 조건을 지정해줄 수 있는 기능이 필요할 수도 있다.

어떤 타입을 제네릭 타입의 타입 파라미터에 대한 상한(upper bound)를 지정하면 그 제네릭 타입을 인스턴화할 때 사용하는 타입 인자는 반드시 그 상한 타입이거나 그 상한 타입의 하위 타입이어야 한다.

제약을 가하려면 타입 파라미터 이름 뒤에 콜론을 표시하고 그 뒤에 상한 타입을 적으면 된다.

- 자바
```
<T extends Number> T sum(List<T> list)
```

- 코틀린
```
fun <T: Number> List<T>.sum(): T
```

### 9.1.4 타입 파라미터를 널이 될 수 없는 타입으로 한정

아무런 타입 상한을 정하지 않은 타입 파라미터는 결과적으로 Any?를 상한으로 정한 파라미터와 같다.



__9.2 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터
____9.2.1 실행 시점의 제네릭: 타입 검사와 캐스트
____9.2.2 실체화한 타입 파라미터를 사용한 함수 선언
____9.2.3 실체화한 타입 파라미터로 클래스 참조 대신
____9.2.4 실체화한 타입 파라미터의 제약
__9.3 변성: 제네릭과 하위 타입
____9.3.1 변성이 있는 이유: 인자를 함수에 넘기기
____9.3.2 클래스, 타입, 하위 타입
____9.3.3 공변성: 하위 타입 관계를 유지
____9.3.4 반공변성: 뒤집힌 하위 타입 관계
____9.3.5 사용 지점 변성: 타입이 언급되는 지점에서 변성 지정
____9.3.6 스타 프로젝션: 타입 인자 대신 * 사용
