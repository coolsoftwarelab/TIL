## 애노테이션과 리플렉션

>Annotation과 Reflection을 사용하면 미리 알지 못하는 임의의 클래스를 다룰 수 있다.
>Annotation을 사용하면 라이브러리가 요구하는 의미를 클래스에게 부여할 수 있고,  
Reflection을 사용하면 실행 시점에 컴파일러 내부 구조를 분석할 수 있다.

### 10.1 애노테이션 선언과 적용

>코틀린에서 Annotation을 사용하는 방법은 자바와 똑같지만 Annotation을 선언할 때 사용하는 문법은 자바와 약간 다르다.

// JUnit @Test 애노테이션
```
@Test
fun testTrue() {}
```

애노테이션에 인자를 지정할 때의 문법이 자바와 약간 다르다.

- 클래스를 애노테이션 인자로 지정할 때는 @MyAnnotation(MyClass::class)처럼 ::class를 클래스 이름 뒤에 넣어야 한다.
- 다른 애노테이션을 인자로 지정할 때는 인자로 들어가는 애노테이션 이름 앞에 @를 넣지 말아야한다.
  + @Deprecated("","ReplaceWith") - replaceWith도 annotation이다.
- 배열을 인자로 지정하려면 @RequestMapping(path = arrayOf("/foo", "/bar"))처럼 arrayOf 함수를 사용한다.  
자바에서 선언한 애노테이션 클래스를 사용한다면 value라는 이름의 파라미터가 필요에 따라 자동으로 가변 길이 인자로 변환된다.  
따라서 그런 경우에는 @JavaAnnotationWithArrayValue("abc", "foo", "bar")처럼 arrayOf 함수를 쓰지 않아도 된다.

- 애노테이션 인자를 컴파일 시점에 알 수 있어야 한다. Ekfktj 프로퍼티를 애노테이션 인자로 사용하려면 그 앞에 const 변경자를 붙여야 한다. (컴파일 시점 상수 취급)

```
const val TEST_TIMEOUT = 100L

@Test(timeout = TEST_TIMEOUT) fun testMethod() { ... }    
```

### 애노테이션 대상

- 자바에 선언된 애노테이션을 사용해 프로퍼티에 애노테이션을 붙이는 경우 사용 시점 대상(use-site target) 선언으로 애노테이션을 붙일 요소를 정할 수 있다.

프로퍼티 getter에 해당 애노테이션을 붙이고 싶은 경우
```
//프로퍼티의 요소에 애노테이션을 적용
@get:MyAnnotation  
val temp = Temp()
```
  
- 코틀린으로 애노테이션을 선언하면 프로퍼티에 직접 적용할 수 있는 애노테이션을 만들 수 있다.

- 사용 시점 대상을 지정할 때 지원하는 목록
    + property : 프로퍼티 전체, 자바에서 선언된 애노테이션에는 이 사용 지점 대상을 사용할 수 없다.
    + field : 프로퍼티에 의해 생성되는 필드
    + get : 프로퍼티 게터
    + set : 프로퍼티 세터
    + receiver : 확장 함수나 프로퍼티의 수신 객체 파라미터
    + param : 생성자 파라미터    
    + setparam : 세터 파라미터    
    + delegate : 위임 프로퍼티의 위임 인스턴스를 담아둔 필드    
    + file : 파일 안에 선언된 최상위 함수와 프로퍼티를 담아두는 클래스

- 자바와 달리 코틀린에서 애노테이션 인자로 클래스나 함수 선언이나 타입외에 임의의 식을 허용한다.


```
fun test(list: List<*>) {
    // 로컬 변수에 캐스팅 경고무시 annotation 적용
    @Supress("UNCHKED_CAST")
    val strings = list as List<String>
}
```

- 자바 api를 annotation으로  제어하기
    + @JvmName: 코틀린 선언이 만들어내는 자바 필드나 메소드 이름을 변경한다.
    + @JvmStatic : 메소드 객체선언, 동반 객체에 적용하면 그 요소가 자바 정적 메소드로 노출된다.
    + @JvmOverloads : 디폴트 파라미터 값이 있는 함수에 대해 자동으로 오버로딩한 함수를 생성한다.
    + @JvmField : 프로퍼티에 사용하면 게터나 세터가 없는 공개된(public)  자바 필드로 프로퍼티를 노출시킨다.

```kotlin
@JvmName("fooListString")
fun foo(a : List<String>) {
    println("foo(a : List<String>)")
}
List<String> listString = new ArrayList<>();
KotlinKt.fooListString(listString);
```

### 10.2 리플렉션 : 실행 시점에 코틀린 객체 내부 관찰

>리플렉션은 실행 시점에(동적으로) 객체의 프로퍼티와 메소드에 접근할 수 있게 해주는 방법이다.

- 타입에 관계없이 객체를 다뤄야 하거나 객체가 제공하는 메소드나 프로퍼티 이름을 오직 실행 시점에만 알 수 있는 경우 사용. (ex. JSON 직렬화 라이브러리)

직렬화 라이브러리는 어떤 객체든 JSON으로 직렬화 할 수 있어야 하지만,  
실행 시점이 되기 전까지는 라이브러리가 직렬화할 프로퍼티나 클래스에 대한 정보를 알 수 없으므로 `리플렉션`을 사용해야 한다.

#### 리플렉션 API
1. java.lang.reflect 패키지 API
2. kotlin.reflect 패키지 API

### 코틀린 리플렉션 API : KClass. KCallable, KFunction, KProperty


1. KClass
>KClass를 사용하면 클래스 안에 있는 모든 선언을 열거하고 각 선언에 접근하거나 클래스의 상위 클래스를 얻는 등의 작업이 가능  
MyClass::class 를 쓰면 인스턴트 획득

```
class Person(val name: String, val age: Int)
>>> val person = Person("Alice", 29)
>>> val kClass = person.javaClass.kotlin  // KClass<Person>의 인스턴스를 반환한다.
>>> println(kClass.simpleName)
Person
>>> kClass.memberProperties.forEach { println(it.name) } 
age
name
```



