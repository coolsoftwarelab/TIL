## 함수, 변수, 클래스, enum, 프로퍼티를 선언하는 방법

### 함수
```
fun main(args: ArrayList<String>) {
    println("Hello world")
}
```
- `fun` 키워드 사용
- 최상위 수준에 정의 가능 (클래스 안에 함수를 넣어야 할 필요없음)
- 코틀린에서는 자바와 달리 배열 처리를 위한 문법이 없다. (클래스처럼 사용)

코틀린 함수 정의 예제
```
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b  
}
```
### statement vs expression
>자바와 달리 코틀린에서는 루프를 제외한 대부분의 제어구조가 expression. 대입문은 statement

1. statement(구문)
 - 값을 만들어내지 않는다.
```
var a = 1   // statement
```

2. expression(표현식)
 - 값을 반환한다. (값을 return 한다)
 - state를 변경하지 않는다.

```
var a = 1 // statement
a + 1     // expression
a * 3     // expression
println(a)  // 출력결과 '1'
```

다른 예
```
// 결과 true. 자바에서 if는 statement이므로 이런식으로 사용 불가
println(if (2 > 1) true else false) 
```

### 왜 statement와 expression 을 알아야 하는가?
- 제어 구조를 다른 식으로 엮어낼 수 있으면 간결하게 표현할 수 있다.

expression body function
```
// 정적 타입 지정언어이므로 expression 은 컴파일러가 `타입추론(type inference` 가능. 
fun max(a: Int, b: Int) = if (a > b) a else b  // max의 반환 타입인 Int 생략가능
```

### 2.1.3 변수

변수선언 키워드
- val : 변경 불가능한 (immutable) 참조를 저장하는 변수 (자바 final 과 동일)
- var : 변경 가능한 (mutable) 참조를 저장하는 변수

val 참조 자체는 불변이라도 해당 객체의 내부 값은 변경 가능
```
val a = arraListOf("hello") // 불변참조 선언
a.add("world")  // 참조가 가리키는 객체 내부를 변경
```

var 키워드를 사용하면 변수의 값을 변경할 수 있지만 타입은 고정돼 바뀌지 않는다.
```
var a = 10
a = "hi"    // compile error : type mismatch
```

### while 과 for 루프

#### 2.4.1 while 루프

>`while`, `do while` 자바와 동일함

```
while(조건){ ... }

do{ ... } while(조건) 
```

#### 수에 대한 이터레이션: 범위와 수열

코틀린에서는 범위(range) 사용. 시작 값과 끝 값 포함
```
val oneToTen = 1..10
```

`in`
```
for( i in 1..5) {
    print(i)  // 1 2 3 4 5
}

for( i in 1..100 step 2) {
    print(i)  // 1 3 5 7 ...
}

// 역방향 증가값 범위 이터레이션
for( i in 100 downTo 1 step 2) {
    print(i)  // 100 98 96 ...
}
```

`..` 연산자는 항상 범위의 끝 값을 포함한다.
닫힌 범위를 만들고 싶다면 `until` 사용.

for(i in 0 until 100) == for(i in 0 .. 99)

### 2.4.3 맵에 대한 이터레이션 

```
val binaryReps = TreeMap<Char, String>()
// 키에 대해 정렬하기 위해 Treemap 사용

for(c in 'A'..'F'){ // A~F
    val binary = Integer.toBinaryString(c.toInt())
    binaryReps[c] = binary
    // c를 key로, 바이너리를 value
}

for((letter, binary) in binaryReps){
// 맵에 대해 이터레이션.
// letter : 맵의 key
// binary : 맵의 value 
    println("$letter = $binary")
}

// result
A = 1000001
B = 1000010
C = 1000011
D = 1000100
E = 1000101
F = 1000110
```

컬렉션 이터레이션
```
val list = arrayListOf("10","11","1001")
for( (index, element) in list.withIndex() ){
//인덱스와 함께 컬렉션 이터레이션
    println("$index: $element")
}


/**
0: 10
1: 11
2: 1001
*/
```

### 2.4.4 in으로 컬렉션이나 범위의 원소 검사

in 연산자는 어떤 값이 범위에 속하는지 검사할 수 있다.  
!in 연산자는 어떤 값이 범위에 속하지 않는지 검사할 수 있다.

```
fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z'
isLetter('q') // true

fun isNotDigit(c: Char) = c !in '0'..'9'
isNotDigit('x') // true
```

비교가 가능한 클래스(java.lang.Comparable 인터페이스를 구현한 클래스)라면,  
그 클래스의 인스턴스 객체를 사용해 범위를 만들 수 있다.

```
// String에 있는 Comparable 구현이 두 문자열을 알파벳 순서로 비교함.
println("Kotlin" in "Java".."Scala")
// true

println("Kotlin" in setOf("Java","Scala"))
// false
```

