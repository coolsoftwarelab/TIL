참조 : https://proandroiddev.com/kotlin-coroutines-channels-csp-android-db441400965f


### Channel

동시성문제를 해결하기위해 채널(Channel) 사용. 채널은 동시성 코드가 메시지를 보내 통신할 수 있도록 해준다.  

채널은 2개의 Coroutine 을 연결한 파이프  
Coroutine 은 다른 Coroutine 에게 채널을 통해 정보를 전달 할 수 있다 (단방향 전송. send->recieve)  

![](https://miro.medium.com/max/700/1*E6FB9W3IemTPp4U5WwGApg.png)

활용 예) Search 작업 3개의 코루틴 실행 각 코루틴의 결과를 받을때마다 실시간으로 UI 업데이트

### Thread의 Communicate 와 채널의 차이점

>쓰레드간 자원공유는 두개의 스레드가 동시에 자원을 쓰지 못하도록 자원을 락(lock)하거나 메모리 공유 (상태값 처리)

- 데드락, 레이스컨디션 발생 문제가 있음

### Channel의 Communication
![](https://miro.medium.com/max/700/1*khfG84QbarNrYDUUkiBmqA.gif)

캐셔는 채널을 통해서 2명의 바리스타와 커뮤니케이션을 한다. 

캐셔는 주문을 받고 채널로 주문을 보낸다. 바리스타가 커피를 만드는 작업을 끝내면 바로 다음 주문을 캐셔에게 받아서 처리한다.

더 이상 받을 주문이없다면  바리스타는 채널을 통해서 주문이 올때까지 suspend 된다.

### 채널의 유형과 배압

배압을 구성하기 위해 채널에 대한 버퍼를 정의할 수 있다.

코루틴은 채널 안의 요소가 버퍼 크기에 도달하면 일시중단된다.

### 언버퍼드 채널(Unbuffered channels)
>버퍼가 없는 채널

1. RendezcousChannel
>버퍼가 없어서 채널에서 send()를 호출하면 리시버가 receive()를 호출할 때까지 일시 중지된다

![](https://miro.medium.com/max/700/1*VNp65vsrMktiDZW9pYSSOw.png)

생성
```
val rendezvousChannel = Channel<Int>()  // 버퍼용량 0과 같음
```

예제
```
fun main()= runBlocking<Unit> {
   val time = measureTimeMillis {
       val channel = Channel<Int>()
       val sender = GlobalScope.launch {
           repeat(10) {
               channel.send(it)
               println("Sent $it")

           }
       }
       channel.receive()
       channel.receive()
   }
    println("took $time ms")
}

>>>                               
Sent 0
Sent 1
took 95 ms
```
채널로부터 수신하는 요소가 두 개 뿐이므로 두 요소만 전송

### 버퍼드 채널

채널 내 요소의 수가 버퍼의 크기와 같을때 송신자의 실행을 중지

#### LinkedListChannel
>중단 없이 무한의 요소를 전송할 수 있다

생성
```
val channel = Channel<Int>(Channel.UNLIMITED)
```

예제
```
val time = measureTimeMillis {
    val channel = Channel<Int>(Channel.UNLIMITED)
    val sender = GlobalScope.launch {
        repeat(5) {
            println("Sending $it")
            channel.send(it)
        }
    }
    delay(500)
}
println("took $time ms")

>>>
Sending 0
Sending 1
Sending 2
Sending 3
Sending 4
took 552 ms
```

![](https://miro.medium.com/max/700/1*SyD6Z-Rj0FdANfCJPW6hwQ.png)

채널의 5개 요소를 처리할 수 있는 리시버가 없더라도 sender가 5개의 요소를 내보낼 수 있다.


#### ArrayChanenl

>버퍼 크기를 `0`부터 최대 `int.MAX_VLUE - 1` 까지 가진다  
가지고 있는 요소의 양이 버퍼 크기에 이르면 송신자를 일시중단한다.

생성
```
 val channel = Channel<Int>(50)
 또는 
 val arrayChannel = ArrayChannel<Int>(50)                             
```

![])https://miro.medium.com/max/700/1*cpm1lOYMVEOgQKWvvClm2Q.png)

```
val time = measureTimeMillis {
  val channel = Channel<Int>(4)
  val sender = GlobalScope.launch {
      repeat(10) {
          channel.send(it)
          println("Sent $it")
      }
  }
  delay(500)
  println("Taking two")
  channel.receiveAsFlow().take(2).collect()
  delay(500)
}
println("Took $time ms")


>>>결과
Sent 0
Sent 1
Sent 2
Sent 3
Taking two
Sent 4
Sent 5
Took 1075 ms
```

### ConflatedChannel
>새로운 요소가 보내질 때마다 이전 요소는 유실된다.

```
val channel = Channel<Int>(Channel.CONFLATED)
```

```
val time = measureTimeMillis {
  val channel = Channel<Int>(Channel.CONFLATED)
  val sender = GlobalScope.launch {
      repeat(5) {
          channel.send(it)
          println("Sent $it")
      }
  }
  delay(500)
  val element = channel.receive()
  println("Received $element")
}
println("Took $time ms")


>>>결과

Sent 0
Sent 1
Sent 2
Sent 3
Sent 4
Received 4  // 전송된 마지막 요소를 갖는다
Took 677 ms
```



