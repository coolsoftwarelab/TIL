### launch(), async()

- 하나 이상의 코루틴을 launch(), 또는 async()로 스레드에서 실행 할 수 있다. 이를 생성하는 것을 `CoroutineBuilder` 라 한다
- CoroutineDispatcher는 코루틴을 특정 스레드 또는 스레드 그룹에서 실행하도록 지정할 수 있다.

1. launch()
- launch()는 코루틴이 연산 결과로 무언가를 반환할 것을 예상하지 않을 때 사용. 
- 실행 시 코루틴을 중단할 수 있는 `Job` 객체를 얻는다.
- 연산이 실패 했을 경우에마나 통보받기를 원할 때 사용
- 결과가 없는 비동기 함수 예시
  - 로그 기록하기, 분석데이터 전송 등

2. async()
- async()는 코루틴이 처리될 결과를 생성할 때 사용. 
- 취소가 불가능한 넌블러킹 Future 인 `Deffered<T>` 를 반환 (자바 Future와 Deffered는 동의어이다)
- async()는 상태에 따른 결과 처리를 해야한다 (isCancelled 등)
- 결과를 반환하는 비동기 함수 예시
  - 웹 서비스로 정보를 가져올 때

### Job

#### 생성
```kotlin
// case 1
val job = GlobalScope.launch { ... }

// case 2
val job = Job()
```
case 1, 2 의 경우 생성즉시 실행된다

#### Job 상태
- new : 존재하지만 실행되지 않음
- cancel : 취소
- cancelling : 취소중
- cancelled : 취소됨
- compete : 완료
- 취소된 jobb과 예외로 인해 실패한 job을 구별하기 위해 CoroutineException Handler를 설정해서 작업을 처리하는 것이 좋다

Job을 생성하자마자 실행하지 않으려면 lazy 사용
```
val job = GlobalScope.launch(start = coroutineStart.LAZY) { }
job.start() // job이 완료되기를 기다리지 않고 종료된다. join() 과는 다른 동작임.
```

### Deffered(지연)

- 결과를 갖는 비동기 함수를 생성하기 위해 Job을 확장한다


생성 예시
```
// case 1 
GlobalScope.aysnc { //background task }

// case 2
CompletableDeffered<List<Article>>()
```


### join(), await()
- task를 join()으로 대기 후 검증(isCancelled)
- task를 await()를 사용해 알아서 예외전파시킴





