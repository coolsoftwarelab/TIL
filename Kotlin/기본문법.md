1.변수와 상수

<pre><code>var a: Int = 10		// var 변수명: 자료형 = 값
val b: Int = 20		// var 상수명: 자료형 = 값 

// 코틀린 형추론
var a = 10		// 변수 var a: Int
val b = 20  	// 값 val b: Int</code></pre>

val 은 자바의 final 과 같다.

2.함수

>fun 함수명(인수1:자료형1, 인수2, 자료형2 ...):반환자료형

Unit 은 자바의 void 와 같다.

<pre><code>fun greet(str: String): Unit {
	println(str)
}

greet("hello world!")</pre></code>

반환값이 Unit일 경우 아래와 같이 반환 자료형 생략 가능

<pre><code>fuc greet(str: String) {
	println(str)
}</pre></code>

3.기본자료형

3.1 숫자형

Double : 64비트 부동소수점
Float : 32비트 부동소수점
Long : 64비트 정수
Int : 32비트 정수
Short : 16비트 정수
Byte : 8비트 정수

>리터럴이란 자료형을 알 수 있는 표기 형식.
리터럴에 따라 코틀린 컴파일러가 자료형 추론.

<pre><code>val a = 10		// val a: Int
val b = 10L		// val a: Long
val c = 10.0	// val c: Double
val d = 10.0f	// val d: Float
</pre></code>

3.1 문자형

String : 문자열
Char : 하나의 문자

**코틀린의 Char는 자바와는 다르게 숫자형이 아니다.**

<pre><code>val str = "Hello world"		// val str: String
val char = 'H'		// val char: Char
</pre></code>

- 여러 줄의 문자열 표현

<pre><code>val str = """This
is
multiple
line
"""</pre></code>

- 문자열 비교
== 사용. 자바의 equals() 와 같다.

<pre><code>val str == "Hello"
if(str == "Hello) {
	println("Hi")
} else {
	println("Bye")
}</pre></code>

**코틀린에서 자바의 == 처럼 오브젝트 비교를 하고 싶다면 === 를 사용한다.**

- 문자열 템플릿
문자열 연결. + 기호나 $, 변수와 글자를 연결할때는 중활호{} 로 변수를 감싼다.

<pre><code>val str == "Hello"
println(str + "World")		// 자바 스타일

// 코틀린
println("$str World")		// Hello World
println("${str}World")	// HelloWorld
</pre></code>

4.배열
<pre><code>val numbers: Array<Int> = arrayOf(1, 2, 3, 4, 5)

val number2 = arrayOf(1, 2, 3, 4, 5)	// 자료형 생략

numbers[0] = 5		// [5, 2, 3, 4, 5]
</pre></code>

 

