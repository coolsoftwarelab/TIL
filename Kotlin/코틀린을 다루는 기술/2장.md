## 2.1 필드와 변수

```
// 불변
val name: String = "Hello"  // 또는 val name = "Hello"

// 가변
var name = "Hello"
```

### 2.1.3 지연 초기화

`val` 지연 초기화  
`by lazy` 를 사용하면 최초 사용시점에 초기화 한다.
```
println("1")
val name: String by lazy { getName() }  // 또는 val name: String by lazy(::getName)
println("2")
println(name)
println(name)
println(name)

fun getName(): String {
    println("getName...")
    return "Hello"
}
```

`val` 지연 초기화 실행결과
```
1
2
getName...
Hello
Hello
Hello
```

var 지연 초기화
```
lateinit var name: String
...
name = getName()
```

잘못된 사용
```
lateinit val name: String   // val 에 lateinit 사용 에러

var name: String by lazy { getName() }  // var 에 by lazy 사용 에러 
```

## 2.2 클래스와 인터페이스

class
```
class Person constructor(name: String) {
    val name: String

    init {
        this.name = name
    }
}
```

class 축약
```
class Person (val name: String)
```

- 코틀린 클래스는 기본적으로 public 이다.
- private, protected, internal 변경자 존재
- 클래스는 기본적으로 상속불가. 상속 가능 키워드는 `open`
- 생성자 정의가 클래스 뒤에 오며, 생성자 구현은 init 블록에 들어가고 init블록은 생성자 파라미터에 접근할 수 있다.

### 2.2.2 인터페이스 구현 및 클래스 확장

인터페이스 확장
```
class Person(val name: String) : Serializable, Comparable<Person> {
    override fun compareTo(other: Person): Int {
        // do something...
        return 0
    }
}
```

클래스 확장
```
open class Person(val name: String)

class Member(name: String, registered: Instance): Person(name)
```

### 2.2.3 클래스 인스턴스화

```
val person = Person("Kim", Intance.now())

//++ 위 코드를 자바로 표현 한다면
Person(String name, Instant registered) {
    this.name = name;
    this.registered = registered;
}

Person(String name) {
    this(name, Instant.now());
}

// 기타 getter, setter 등을 정의
```

코틀린은 컴파일러가 알아서 클래스 getter, setter를 생성한다.
```
val person = Person("test")
println(person.name)
```

### 2.2.4 프로퍼티 생성자 오버로드

```
class Person(val name: String, val registered: Instant= Instant.now())
```

### 2.2.5 equals 와 hashCode 메서드 만들기

class 앞에 `data` 키워드만 붙이면 된다.  
추가로 toString 과 copy 함수도 생성된다.

```
class Person(val name: String, val registered: Instant= Instant.now())
```

### 2.2.7 정적 메서드 구현

코틀린에는 정적 멤버가 없고 대신 동반객체(companion object) 가 있다.

```
class Person() {
    companion object {
        fun showMsg() {
            ...
        }
    }
}
```

정적 호출
```
Person.showMsg()
```

### 2.2.8 싱글턴

`object` 키워드 사용
```
object Person {
    fun showMsg() {
        println("Hello")
    }
}

// 싱글턴 객체에는 생성자가 있을 수 없다.
Person.showMsg()
```

### 2.2.9 유틸리티 클래스 인스턴스화 방지하기

자바에서 정적 메서드만 필요한 유틸리티 클래스를 코틀린으로 생성

아무 파일 생성 후 패키지 선언을 하고 클래스에 포함되지 않는 함수를 정의한다.

```
package com.test.util

fun create(name: String) {
    ...
}

// 사용법
import com.test.util.*

val person = create("kim")
```

## 2.3 원시 타입이 없음

>코틀린에는 원시 타입(primitive type)이 없다.  
(내부에서 자바 원시 타읍으로 계산하고 개발자는 오직 객체만 조작)

- Long : 10L
- Float : 10F
- Double : 10.0
- 16진수 : `0x`10
- 2진수 : `0b`10110101



