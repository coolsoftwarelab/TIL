## 2.1 필드와 변수

```
// 불변
val name: String = "Hello"  // 또는 val name = "Hello"

// 가변
var name = "Hello"
```

### 2.1.3 지연 초기화

`val` 지연 초기화  
`by lazy` 를 사용하면 최초 사용시점에 초기화 한다.
```
println("1")
val name: String by lazy { getName() }  // 또는 val name: String by lazy(::getName)
println("2")
println(name)
println(name)
println(name)

fun getName(): String {
    println("getName...")
    return "Hello"
}
```

`val` 지연 초기화 실행결과
```
1
2
getName...
Hello
Hello
Hello
```

var 지연 초기화
```
lateinit var name: String
...
name = getName()
```

잘못된 사용
```
lateinit val name: String   // val 에 lateinit 사용 에러

var name: String by lazy { getName() }  // var 에 by lazy 사용 에러 
```

## 2.2 클래스와 인터페이스

class
```
class Person constructor(name: String) {
    val name: String

    init {
        this.name = name
    }
}
```

class 축약
```
class Person (val name: String)
```

- 코틀린 클래스는 기본적으로 public 이다.
- private, protected, internal 변경자 존재
- 클래스는 기본적으로 상속불가. 상속 가능 키워드는 `open`
- 생성자 정의가 클래스 뒤에 오며, 생성자 구현은 init 블록에 들어가고 init블록은 생성자 파라미터에 접근할 수 있다.

### 2.2.2 인터페이스 구현 및 클래스 확장

인터페이스 확장
```
class Person(val name: String) : Serializable, Comparable<Person> {
    override fun compareTo(other: Person): Int {
        // do something...
        return 0
    }
}
```

클래스 확장
```
open class Person(val name: String)

class Member(name: String, registered: Instance): Person(name)
```

### 2.2.3 클래스 인스턴스화

```
val person = Person("Kim", Intance.now())

//++ 위 코드를 자바로 표현 한다면
Person(String name, Instant registered) {
    this.name = name;
    this.registered = registered;
}

Person(String name) {
    this(name, Instant.now());
}

// 기타 getter, setter 등을 정의
```

코틀린은 컴파일러가 알아서 클래스 getter, setter를 생성한다.
```
val person = Person("test")
println(person.name)
```

### 2.2.4 프로퍼티 생성자 오버로드

```
class Person(val name: String, val registered: Instant= Instant.now())
```

### 2.2.5 equals 와 hashCode 메서드 만들기

class 앞에 `data` 키워드만 붙이면 된다.  
추가로 toString 과 copy 함수도 생성된다.

```
class Person(val name: String, val registered: Instant= Instant.now())
```

### 2.2.7 정적 메서드 구현

코틀린에는 정적 멤버가 없고 대신 동반객체(companion object) 가 있다.

```
class Person() {
    companion object {
        fun showMsg() {
            ...
        }
    }
}
```

정적 호출
```
Person.showMsg()
```

### 2.2.8 싱글턴

`object` 키워드 사용
```
object Person {
    fun showMsg() {
        println("Hello")
    }
}

// 싱글턴 객체에는 생성자가 있을 수 없다.
Person.showMsg()
```

### 2.2.9 유틸리티 클래스 인스턴스화 방지하기

자바에서 정적 메서드만 필요한 유틸리티 클래스를 코틀린으로 생성

아무 파일 생성 후 패키지 선언을 하고 클래스에 포함되지 않는 함수를 정의한다.

```
package com.test.util

fun create(name: String) {
    ...
}

// 사용법
import com.test.util.*

val person = create("kim")
```

## 2.3 원시 타입이 없음

>코틀린에는 원시 타입(primitive type)이 없다.  
(내부에서 자바 원시 타읍으로 계산하고 개발자는 오직 객체만 조작)

- Long : 10L
- Float : 10F
- Double : 10.0
- 16진수 : `0x`10
- 2진수 : `0b`10110101

## 2.4 컬렉션의 두 유형

>코틀린 컬렉션에는 불변(immutable)과 가변(mutable) 두 가지 유형이 있다.  
기본적으로 컬렉션은 불변(엄격한 의미의 불변은 아님)

불변 리스트 생성
```
val list = listOf(1, 2, 3)
```

불변성 리스트라고 리스트 대한 연산을 못하는 것은 아니다.
```
val list1 = listOf(1, 2, 3)
val list2 = list1 + 4
println(list2)

//결과
[1, 2, 3, 4]
```
list1, list2 자체는 변하지 않았다.

가변 리스트
```
val list1 = mutableListOf(1,2,3)
val list2 = list1.add(4)
val list3 = list1.addAll(list1)
println(list1)
println(list2)
println(list3)

// 결과
[1, 2, 3, 4, 1, 2, 3, 4]
true
true
```

## 2.5 패키지

>코틀린 패키지에서는 패키지가 저장된 디렉터리 구조와 패키지의 이름을 서로 일치시킬 필요가 없다.  
일반적으론 자바 패키지 규칙을 따르는게 좋다.

## 2.6 가시성

- private
자신이 정의된 클래스 안에서만 접근.  

코틀린에서는 외부 클래스에 정의된 비공개 멤버를 내부 클래스에서 볼 수 없다.

클래스 생성자는 기본적으로 public 가시성.

- protected
- internal 
- public

## 2.7 함수

### 2.7.1 함수 선언하기

함수
```
fun add(a: Int, b: Int): Int {
    return a + b
}
```

함수 축약
```
fun add(a: Int, b: Int) = a + b
```

축약으로 의도하지 않는 결과가 나오는 함수
```
fun add(a: Int, b: Int) {
    a + b
}

// 결과
kotlin.Unit
```

### 2.7.1 로컬 함수 사용

>클래스나 객체 안에서 함수를 정의할 수 있다. 더 나아가 함수 내부에서도 함수를 정의할 수 있다.

### 2.7.2 로컬 함수 사용

>함수 내부에 함수를 중첩. 바깥 함수의 파라미터에 접근가능

코드중복 예제
```
class User(val id: Int, val name: String, val address: String)

fun saveUser(user: User) {
    if (user.name.isNullOrEmpty()) {
        println("Name 항목을 입력해주세요.")
    }

    if (user.address.isNullOrEmpty()) {
        println("Address 항목을 입력해주세요.")
    }
}
```

로컬함수 사용
```
class User(val id: Int, val name: String, val address: String)

fun saveUser(user: User) {
    fun validate(value: String, fieldName: String) {
        if (value.isNullOrEmpty()) {
            println("${user.id}의 ${fieldName} 항목을 입력해주세요.")
        }
    }

    validate(user.name, "Name")
    validate(user.address, "Address")
}
```

### 2.7.3 함수 오버라이드

>override 키워드를 반드시 붙여야 한다.

```
override fun toString() = ...
```


### 2.7.4 확장 함수 사용

>자바의 static method 와 같음

```
fun main() {
    val a = "test".firstChar()  // a is 't'
}

fun String.firstChar(): Char = this[0]
```

### 2.7.5 람다

>람다는 익명 함수(anonymous function)

익명 함수
```
val say = fun(){ println("Hello") }
say()
```

람다 사용
```
val say: () -> Unit = {println("Hello")}
say()
```

클로저 안의 람다
```
val multiplier = 3

fun multiplyAll(list: List<Int>): List<Int> = list.map { it * multiplier }
```

## 2.8 널

`?` 키워드
```
val city: City? = map[companyName]?.manager?.address?.city
```

엘비스 연산자 (?:) 로 null 발생 시 특정값 리턴
```
val city: City? = map[companyName]?.manager?.address?.city ?: City.UNKNOWN
```

## 2.9 프로그램 흐름과 제어구조

if else
```
val result = if(a>b) {
                "hello"
             } else {
                "world"
             }
```

when
```

val result = when(a) {
    1 -> "first"
    2 -> "second"
    else -> "unkwon"
}
```

## 2.10 비검사 예외

>자바와 달리 모든 예외는 비검사 예외(unchecked) 예외다.  
코틀린에서는 try catch finally 구조가 값을 돌려주는 식 이다.

```
lateinit var a: String

val num: Int = try {
    a.toString().length
} catch (e: Exception) {
    -1
} finally {
    println("its finally block")    // 항상 실행
    0
}

println(num)

//결과 
its finally block
-1
```

## 2.11 사용한 자원 자동으로 닫기

`use` 키워드 사용
```
File("myFile.txt").inputStream()
                  .use {
                    it.bufferedReader()
                      .lineSequence()
                      .forEach (::println)
                  }
```



