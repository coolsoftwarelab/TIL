## 2.13 동일성과 동일성

>동등성(equality)과 동일성(identity)는 다르다.
#### Java
- 객체 동등성 : `equals`
- 원시 타입 및 객체 동일성 : `==`

#### Kotlin
- 동일성, 즉 참조 동등성(referential quality)는 `===` 로 검사한다.
- 동등성, 즉 구조 동등성(structural equality)는 `==` 로 검사하며, eqauls와 `==` 는 같다.


## 2.14 문자열 인터폴레이션
#### Java
```
System.out.println(String.format("%s's registration date : %s", name, date))
```

#### Kotlin
```
println("$name's registration date: ${date}")
```

문자안에 식을 넣을 수도 있으며 이런 기법을 문자열 인터폴레이션(string interpolation)이라고 부른다.

## 2.15 여러 줄 문자열

3중 따옴표("""")를 사용해 여러 줄로 이뤄진 문자열 사용

```
println("""first line
            | second line
        """.trimMargin())
```

## 2.16 변성 : 파라미터화한 타입과 하위 타입

>변성(variance)은 파라미터화한 타입이 서로 어떤 하위 타입 관계에 있는지 결정하는 방식이다.

#### 무공변성(invariant)

상속 관계에 상관없이 자신의 타입만 허용하는 것을 뜻한다.  
Kotlin에서는 따로 지정해주지 않으면 기본적으로 모든 Generic Class는 무공변이다.  
Java에서의 `<T>` 와 같다.

#### 공변성(covariance)

자기 자신과 자식 객체를 허용한다.  
Java에서의 `<? extends T>`와 같다.  
Kotlin에서는 `out` 키워드를 사용해서 이를 표시한다.

### 반공변성

자기 자신과 부모 객체만 허용한다.  
Java에서의 `<? super T>` 와 같다.  
Kotlin에서는 `in` 키워드를 사용해서 표현한다.

** out과 in 중 어떤 것을 선택
- 타입을 오직 출력(반환 값)에 쓰면 out
- 타입을 입력(인자 값)에 쓰면 in

### 2.16.1 변성의 문제

자바는 List<A>와 List<B> 는 컴파일 시점엔 다른 타입, 런타임엔 같은 타입 (무공변성)

공변성. `out` 사용  
MutableList<Any>와 MutableList<String>을 동시에 MutableList<T>라는 제네릭 타입에 일치시킬 수 없다.  
 
MutableList<Any>가 MutableList<T>의 상위 타입으로 쓸 수 있음을 컴파일러에 알림.
```
fun <T> addAll(list1: MutableList<T>, 
            list2: MutableList<out T>) { // T 를 공변성으로 만듦
            for(e in list2) list1.add(e)
}

val ls = mutableListOf("A String")
val la: MutableList<Any> = mutableListOf()
addAll(la, ls) // 오류 발생 안함
```

### 2.16.2 공변성을 써야 하는 경우와 반공변성을 써야 하는 경우

            
T 타입을 반환만 하는 인터페이스            
```
interface Bag<out T> {
  fun get(): T
}
```

out 키워드를 사용해 타입 파라미터를 공변성으로 지정해야 한다.
```
open class MyClassParent

class MyClass: MyClassParent()

interface Bag<out T> {
  fun get(): T
}

class Basgmpl: Bag<MyClass> {
  override fun get(): MyClass = MyClass()
}

val bag: Bag<MyClassParent> = BagImpl()
```

T타입을 인자로 받는 인터페이스  
in을 사용해 타입 파라미터를 반공변성 만듦
```
open class MyClassParent

class MyClass: MyClassParent()

interface Bag<in T> {
  fun use(t: T): Boolean
}

class Basgmpl: Bag<MyClass> {
  override fun use(t: MyClassParent): Boolean = true
}

val bag: Bag<MyClass> = BagImpl()
```

### 2.16.3 사용 지점 변성과 선언 지점 변성

2.16.2 의 선언 지점 변성을 사용하지 못하는 경우.

소비하는 동시에 생산하면 변성 지정 안됨.
```
interface Bag<out T> {
  fun get(): T
  fun use(t: T): Boolean
}
```

사용지점 변성 in
```
interface Bag<out T> {
  fun get(): T
  fun use(t: T): Boolean
}

class Basgmpl: Bag<MyClassParent> {
  override fun get(): MyClassParent = MyClassParent()
  override fun use(t: MyClassParent): Boolean = true
}

// 사용지점에서 in으로 타입을 제한
fun useBag(bag: Bag<in MyClass>): Boolean {
  // bag으로 작업 수행
  return true 
}
```

사용지점 변성 out
```
fun createBag(): Bag<out MyClassParent> = BagImpl2()

class BagImpl2: Bag<MyClass) {
  override fun use(t: MyClass): Boolean = true
  override fun get(): MyClass = MyClass()
}
```


