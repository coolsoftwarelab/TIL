### 로그
print : 단순 문자열 출력
dump : 자세한 로그

### 변수와 상수
상수
```
let test: String = "msg"

let test = "msg"

let test: String // 나중에 할당할 경우 반드시 타입 명시
test = "msg"  // 상수는 선언 후 첫 할당만 가능
```

변수
```
var test: String = "test"
var test = "test"
```

### 기본 데이터 타입
>데이터 타입에 엄격함. 다른 데이터 타입 간 대입 불가 
ex)Int 값을 UInt, Double에 Float, Charater 값을 String 에 대입 불가

- Bool
- Int
- UInt
- Flaot
- Double
- Character
- String

### Any, AnyObject, nil

Any : 어떤 타입도 대입 가능 (nil 은 안됨)
AnyObject : 어떤 객체도 대입가능 (nil 은 안됨)
nil : 없음(null)

### 컬렉션 타입

- Array (ArrayList)
- Dictionary (키,쌍)
- Set (순서, 중복없음)

```
// Array
var intArr: Array<Int> = Array<Int>()
intArr.append(1)

var doubleArr: Array<Double> = [Double]()

var strArr: [String] = [String]()
var strArr: [String] = []

// let Array 는 변경불가
let immutableArr = [1, 2, 4]
immutableArr.append(6) // error
immutableArr.removeAll() // error

// Dictionary
var anyDictionary: Dictionary<String, Any> = [String: Any]()
anyDictionary["someKey"] = 100
anityDictionary.removeValue(forKey: "someKey")

// Set

var intSet: Set<Int> = Set<Int>()

let setA: Set<Int> = [1, 2, 3, 4, 5]
let setB: Set<Int> = [3, 4, 5, 6, 7]
let union: Set<Int> setA.unition(setB) // 합집합
```
### 함수

func 함수이름(매개변수이름: 타입, 매개변수이름: 타입 ...) -> 반환타입 {
  함수 구현부
  return
}

```
func printMyName(name: String) -> Void {
  print(name)
}

func hello() {
  print("hello")
}

// 함수를 호출할 때에는 전달인자 레이블을 사용해야 한다.
sum(a: 3, b: 5)

// 함수의 매개변수 기본값
func greeting(a: String, b: String = "test") {...}
greeting(a: "one")
greeting(a: "one", b: "Two")

// 전달인자 레이블
// 함수 내부에서 전달인자를 사용할 때는 매개변수 이름을 사용
func greeting(to freind: String, from me: String) {
  print("Hello \(freind)! I'm \(me)")
}
// 함수를 호출할 때는 전달인자 레이블을 사용
greeting(to: "one", from: "two")

// 가변 매개변수. 함수당 하나.
func greeting(freind: String, me: String...) {
  print("Greeting \(freind)! I'm \(me)")
}
greeting(freind: "one", me: "two", "three")
greeting(freind: "one")

// Swift 함수는 일급객체 이므로 변수, 상수 등에 저장하고 매개변수로도 전달 가능.
// 반환타입은 생략 불가
// (매개변수타입, 매개변수타입 ...) -> 반환타입

func greeting(to freind: String, from me: String) {
  print("Hello \(freind)! I'm \(me)")
}

var someFunction: (String, String) -> Void = greeting(to:from:)
someFunction("a", "b")  // "Hello a! I'm b
someFunction = greeting(to:from:) // 대입가능, 타입이 다른 함수는 대입안됨

함수를 직접 전달도 가능
func test(paramFunc: (String, String) -> Void) {
  paramFunc("a" ,"b")
}

test(paramFunc: greeting(friend:me:))
test(paramFunc: someFunction)
```

### 조건문 

#### if-else
- 기본적으로 java 와 비슷 
- if-else 는 Bool type만 사용가능략
- 괄호 생략 가능


#### switch
- 정수 외의 대부분 기본 타입 사용 가능
- 명시적 break 불필요

```
switch `value` {
case `pattern`:
  `code`
case `pattern`, `pattern` ...: // break가 없으므로.
default:
  `code`
```

### 반복문
>for-in  
while  
repeat-while

1. for-in
```
var intArr = [1, 2, 3]
let people = ["one": 10, "two": 15, "three": 12]    // Dictionary

for value in intArr {
  print(value)
}

// Dictionary for in
for (name, age) in people {
  print("(name):\(age)")
}
```

2. While
```
while intArr.count > 1 {
  intArr.removeLast()
}
```

3. repeat-while
> do-while 과 비슷

```
repeat {
  intArr.removeLast()
} while intArr.count > 0
```

### Optional
>값이 있을 수도, 없을 수도 있다. nil의 가능성을 명시적 표현

1. '?' 
```
func test(someParam: Int?)  // '?' 인자로 nil 도 가능
test(someParam: nil)
```

2. '!'
```
var value: Int! = 100 // 값 강제 추출 가능함을 미리 선언

// 값의 안전한 추출 if-let
// name 변수는 if-let 구문안에서만 사용가능
var myName: String! = nil
if let name: String = myName {
  print(name)
} else {
  print("name is nil")
}

// 값 강제 추출
var MyName: String! = nil
print(myName!)  // 강제 추출하면 nil 이므로 런타임 오류
```

### 구조체 (structure)
>struct 이름 {
  구현부
}

```
struct Sample {
  var mutableProperty: Int = 100 // 가변 프로퍼티
  let immutableProperty: Int = 100 // 불변 프로퍼티
  static var typeProperty: Int = 100 // 타입 프로퍼티
  
  // 인스턴트 메소드
  func instanceMethod { print("instanceMethod") }
  
  // 타입 메소드
  static func typeMethod { print("typeMethod") }
}
```

구조체의 사용
```
* 가변 객체
var mutable: Sample = Sample()
mutable.mutableProperty = 1000
// mutable.immutableProperty = 1000  // error

* 불변 객체
let immutable: Sample = Sample() 
// mutable.mutableProperty = 1000 // error. 불변 객체이므로 수정 불가
// mutable.immutableProperty = 1000  // error. 불변 객체이므로 수정 불가
Sample.typeMethod() 

* 타입 프로퍼티 및 메소드
Sample.typeProperty = 1000
Sample.typeMethod()
```
#### Class
>class는 참조타입, 구조체는 값 타입  

var, let 객체 모두 구조체와 다르게 java 인스턴스 처럼 동작함  
(구조체에서는 let 에 할당된 객체는 프로퍼티 수정 불가)

```
var mutableRef: Sample = Sample()
mutableRef.mutableProperty = 1000

let immutableRef: Sample = Sample()
immutableRef.mutableProperty = 1000
```

#### 열거형 (Enum)

>enum 은 타입이다.
각 case 는 그 자체가 고유의 값. 메소드 추가 가능


```
enum Weekday {
  case mon
  case tue
  case wed
  case thu, fri, sat, sun
  
  func printMessage() {
    switch self {
    case .mon:
      print("monday1")
    ...
    }
  }
}

var day: Weekday = Weekday.mon
day = .tue  // day 변수는 Weekday 타입이므로 축약해서 .tue 처럼 표기가능
print(day)

Weekday.mon.printMessage()
```

Hashable 프로토콜을 따르는 모든 타입이 원시값의 타입으로 지정될 수 있다.
```
enum Fruit: Int {
  case apple = 0
  case grape = 1
}

print("apple raw = \(Fruit.apple.rawValue)")
```

### 값 타입과 참조 타입

1. Class : 참조타입  
2. Struct : 값 타입
3. enum : 값 타입

>스위프트는 구조체, 열거형 사용을 선호.  
Apple 프레임워크는 대부분 클래스 사용.  
Apple 프레임워크 사용 시 구조체/클래스 선택은 우리의 몫

### Closure (클로저)
>**코드의 블럭**, 일급 시민(first-citizen, 변수 상수등으로 저장, 전달인자로 전달이 가능. 함수는 이름이 있는 클로저 이다.
자바 콜백 비슷

```
{ (매개변수 목록) -> 반환타입 in
  실행코드
}
```

#### 기존 함수 형태로 사용 예시
```
func sumFunc(a: Int, b: Int) -> Int {
  return a + b
}

var result: Int = sumFunc(a: 1, b: 2)
print(result)  // 3
```

#### 클로저 사용
```
var sum: (Int, Int) -> Int = { (a: Int, b: Int) -> Int in 
  return a + b
}
var result = sum(1, 2)
print(result)  // 3


// 함수는 클로저의 일종이므로 변수에 함수를 할당 가능
sum = sumFunc(a:b:)
result = sum(1, 2)
print(result)  // 3
```

#### 클로저의 활용

```
func calculate(a: Int, b: Int, method: (Int, Int) -> Int) -> Int {
  // 함수 안에서 파라미터로 전달받은 method 를 호출한다. (콜백같은)
  return method(a, b)
}

// 변수에 할당된 클로저
let add: (Int, Int) -> Int
add = { (a: Int, b: Int) -> Int in
  return a + b
}

// calculate 함수 호출 시 클로저를 넘기는 예시
// 클로저 `add` 가 파라미터로 전달되고 실행된다
calculate(a: 1, b: 2, method: add) // 3

// `add` 에 있는 코드 블록(클로저)을 전달해도 당연히 잘 동작함. (자바 익명함수 처럼 동작)
calculate(a: 1, b: 2, method: { (a: Int, b: Int) -> Int in
  return a + b
}) // 3
```

축약하지 않은 클로저 문법과 축약 후의 문법 비교
```
// 전체
result = calculate(a: 10, b: 10, method: { (left: Int, right: Int) -> Int in
  return left + right
})

// 후행클로저 + 반환타입 축약
result = calculate(a: 10, b: 10) { (left: Int, right: Int) in
  return left + right
})

// 전체 축약
result = calculate(a: 10, b: 10) { $0 + $1 }

print(result)
```
