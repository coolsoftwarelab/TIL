### 로그
print : 단순 문자열 출력
dump : 자세한 로그

### 변수와 상수
상수
```
let test: String = "msg"

let test = "msg"

let test: String // 나중에 할당할 경우 반드시 타입 명시
test = "msg"  // 상수는 선언 후 첫 할당만 가능
```

변수
```
var test: String = "test"
var test = "test"
```

### 기본 데이터 타입
>데이터 타입에 엄격함. 다른 데이터 타입 간 대입 불가 
ex)Int 값을 UInt, Double에 Float, Charater 값을 String 에 대입 불가

- Bool
- Int
- UInt
- Flaot
- Double
- Character
- String

### Any, AnyObject, nil

Any : 어떤 타입도 대입 가능 (nil 은 안됨)
AnyObject : 어떤 객체도 대입가능 (nil 은 안됨)
nil : 없음(null)

### 컬렉션 타입

- Array (ArrayList)
- Dictionary (키,쌍)
- Set (순서, 중복없음)

```
// Array
var intArr: Array<Int> = Array<Int>()
intArr.append(1)

var doubleArr: Array<Double> = [Double]()

var strArr: [String] = [String]()
var strArr: [String] = []

// let Array 는 변경불가
let immutableArr = [1, 2, 4]
immutableArr.append(6) // error
immutableArr.removeAll() // error

// Dictionary
var anyDictionary: Dictionary<String, Any> = [String: Any]()
anyDictionary["someKey"] = 100
anityDictionary.removeValue(forKey: "someKey")

// Set

var intSet: Set<Int> = Set<Int>()

let setA: Set<Int> = [1, 2, 3, 4, 5]
let setB: Set<Int> = [3, 4, 5, 6, 7]
let union: Set<Int> setA.unition(setB) // 합집합
```
### 함수

func 함수이름(매개변수이름: 타입, 매개변수이름: 타입 ...) -> 반환타입 {
  함수 구현부
  return
}

```
func printMyName(name: String) -> Void {
  print(name)
}

func hello() {
  print("hello")
}

// 함수를 호출할 때에는 전달인자 레이블을 사용해야 한다.
sum(a: 3, b: 5)

// 함수의 매개변수 기본값
func greeting(a: String, b: String = "test") {...}
greeting(a: "one")
greeting(a: "one", b: "Two")

// 전달인자 레이블
// 함수 내부에서 전달인자를 사용할 때는 매개변수 이름을 사용
func greeting(to freind: String, from me: String) {
  print("Hello \(freind)! I'm \(me)")
}
// 함수를 호출할 때는 전달인자 레이블을 사용
greeting(to: "one", from: "two")

// 가변 매개변수. 함수당 하나.
func greeting(freind: String, me: String...) {
  print("Greeting \(freind)! I'm \(me)")
}
greeting(freind: "one", me: "two", "three")
greeting(freind: "one")

// Swift 함수는 일급객체 이므로 변수, 상수 등에 저장하고 매개변수로도 전달 가능.
// 반환타입은 생략 불가
// (매개변수타입, 매개변수타입 ...) -> 반환타입

func greeting(to freind: String, from me: String) {
  print("Hello \(freind)! I'm \(me)")
}

var someFunction: (String, String) -> Void = greeting(to:from:)
someFunction("a", "b")  // "Hello a! I'm b
someFunction = greeting(to:from:) // 대입가능, 타입이 다른 함수는 대입안됨

함수를 직접 전달도 가능
func test(paramFunc: (String, String) -> Void) {
  paramFunc("a" ,"b")
}

test(paramFunc: greeting(friend:me:))
test(paramFunc: someFunction)
```

### 조건문 
- if-else
- swtich

if-else
- 기본적으로 java 와 비슷 
- if-else 는 Bool type만 사용가능략
- 괄호 생략 가능


switch

- 정수 외의 대부분 기본 타입 사용 가능
- 명시적 break 불필요

```
switch `value` {
case `pattern`:
  `code`
case `pattern`, `pattern` ...: // break가 없으므로.
default:
  `code`
```

### 반복문
>for-in  
while  
repeat-while

1. for-in
```
var intArr = [1, 2, 3]
let people = ["one": 10, "two": 15, "three": 12]    // Dictionary

for value in intArr {
  print(value)
}

// Dictionary for in
for (name, age) in people {
  print("(name):\(age)")
}
```

2. While
```
while intArr.count > 1 {
  intArr.removeLast()
}
```

3. repeat-while
> do-while 과 비슷

```
repeat {
  intArr.removeLast()
} while intArr.count > 0
```

### Optional
>값이 있을 수도, 없을 수도 있다. nil의 가능성을 명시적 표현

```
1. '?' 
```
func test(someParam: Int?)  // '?' 인자로 nil 도 가능
test(someParam: nil)
```

2. '!'
```
var value: Int! = 100 // 값 강제 추출 가능함을 미리 선언

// 값의 안전한 추출 if-let
// name 변수는 if-let 구문안에서만 사용가능
var myName: String! = nil
if let name: String = myName {
  print(name)
} else {
  print("name is nil")
}

// 값 강제 추출
var MyName: String! = nil
print(myName!)  // 강제 추출하면 nil 이므로 런타임 오류
```

### 구조체 (structure)
>struct 이름 {
  구현부
}

```
struct Sample {
  var mutableProperty: Int = 100 // 가변 프로퍼티
  let immutableProperty: Int = 100 // 불변 프로퍼티
  static var typeProperty: Int = 100 // 타입 프로퍼티
  
  // 인스턴트 메소드
  func instanceMethod { print("instanceMethod") }
  
  // 타입 메소드
  static func typeMethod { print("typeMethod") }
}
```




